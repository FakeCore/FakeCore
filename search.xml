<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shm与mmap</title>
      <link href="/shm-mmap/"/>
      <url>/shm-mmap/</url>
      
        <content type="html"><![CDATA[<p>shmget 和 shm_open+mmap是两种不同的共享内存用法,</p><p>shmget是老式system V 模型,</p><p>shm_open 是POSIX下的产物.</p><p>mmap和System V共享内存的主要区别在于：</p><ul><li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li><li>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。</li></ul><p>内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。</p><ul><li>匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。</li><li>文件映射有<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code>两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。</li></ul><p>shmget用法 shmget(IPC_PRIVATE,size,flag)</p><p>shm_open 创建一个共享内存(文件,&#x2F;dev&#x2F;shm下),返回一个fd.通过ftruncate指定文件大小</p><p>mmap通过fd attach上这个地址,进行操作</p><h2 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h2><p>compared to shm_open+mmap, shm_get used the old System V shared memory model.</p><pre><code class="c">#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);</code></pre><p>key: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.</p><p>获取一个特定shm</p><p>size: A new shared memory segment, with size equal to the value of size rounded up to a  multi-<br>       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE,<br>       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-<br>       flg.</p><p> If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-<br>       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the<br>       effect of the combination O_CREAT | O_EXCL for open(2).)</p><p>如果shmflag同时指定了<code>IPC_CREAT</code> 和<code>IPC_EXCL</code>,同时有一个已存在的KEY共享内存,shmget将会失败.</p><p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and<br>       errno is set to indicate the error.</p><p>可以理解成返回一个fd,指向可用的shm segement</p><h2 id="shm-open-mmap"><a href="#shm-open-mmap" class="headerlink" title="shm_open+mmap"></a>shm_open+mmap</h2><pre><code class="c">#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;        /* For mode constants */#include &lt;fcntl.h&gt;           /* For O_* constants */int shm_open(const char *name, int oflag, mode_t mode);int shm_unlink(const char *name);Link with -lrt.</code></pre><p>shm_open: 可以创建或者打开已存在的shm segement.</p><p><code>open</code> is the same as <code>shm_open</code>.</p><p>shm_unlink: 关闭shm segement</p><p> <strong>oflag</strong> is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any<br>       of the other flags listed here:</p><pre><code>   O_RDONLY          Open the object for read access.  A shared memory object opened in this way can be          mmap(2)ed only for read (PROT_READ) access.   O_RDWR Open the object for read-write access.   O_CREAT          Create the shared memory object if it does not exist.  The user and  group  owner-          ship  of  the object are taken from the corresponding effective IDs of the calling          process, and the object&#39;s permission bits are set according  to  the  low-order  9          bits  of  mode,  except that those bits set in the process file mode creation mask          (see umask(2)) are cleared for the new object.  A set of macro constants which can          be  used to define mode is listed in open(2).  (Symbolic definitions of these con-          stants can be obtained by including &lt;sys/stat.h&gt;.)          A new shared memory object initially has zero length--the size of the  object  can          be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object          are automatically initialized to 0.   O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-          ready exists, return an error.  The check for the existence of the object, and its          creation if it does not exist, are performed atomically.   O_TRUNC          If the shared memory object already exists, truncate it to zero bytes.</code></pre><p><strong>mmap</strong></p><pre><code class="c"> #include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags,           int fd, off_t offset);int munmap(void *addr, size_t length);//See NOTES for information on feature test macro requirements.</code></pre><pre><code>mmap() creates a new mapping in the virtual address space of the       calling process.  The starting address for the new mapping is       specified in addr.  The length argument specifies the length of       the mapping (which must be greater than 0).RETURN VALUEOn success, mmap() returns a pointer to the mapped area.  On       error, the value MAP_FAILED (that is, (void *) -1) is returned,       and errno is set to indicate the error.On success, munmap() returns 0.  On failure, it returns -1, anderrno is set to indicate the error (probably to EINVAL).</code></pre><p><strong>ftruncate</strong></p><p>把文件size变到指定大小</p><pre><code class="c">#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int truncate(const char *path, off_t length);int ftruncate(int fd, off_t length);</code></pre><pre><code>The truncate()  and ftruncate() functions cause the regular file named by path or refer-       enced by fd to be truncated to a size of precisely length bytes.If the file previously was larger than this size, the extra data is lost.   If  the  file   previously was shorter, it is extended, and the extended part reads as null bytes (&#39;\0&#39;).   The file offset is not changed.   If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last   status change and time of last modification; see inode(7)) for the file are updated,  and   the set-user-ID and set-group-ID mode bits may be cleared.   With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be   writable.</code></pre><p>simply code</p><pre><code class="c">//get.c#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define STORAGE_ID &quot;/SHM_TEST&quot;#define STORAGE_SIZE 32int main(int argc, char *argv[])&#123;    int res;    int fd;    char data[STORAGE_SIZE];    pid_t pid;    void *addr;    pid = getpid();    // get shared memory file descriptor (NOT a file,but act as a regular file)    fd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);    if (fd == -1)    &#123;        perror(&quot;open&quot;);        return 10;    &#125;    // map shared memory to process address space    addr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);    if (addr == MAP_FAILED)    &#123;        perror(&quot;mmap&quot;);        return 30;    &#125;    // place data into memory    memcpy(data, addr, STORAGE_SIZE);    printf(&quot;PID %d: Read from shared memory: \&quot;%s\&quot;\n&quot;, pid, data);    return 0;&#125;</code></pre><pre><code class="c">//set.c#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define STORAGE_ID &quot;/SHM_TEST&quot;#define STORAGE_SIZE 32#define DATA &quot;Hello, World! From PID %d&quot;int main(int argc, char *argv[])&#123;    int res;    int fd;    int len;    pid_t pid;    void *addr;    char data[STORAGE_SIZE];    pid = getpid();    sprintf(data, DATA, pid);    // get shared memory file descriptor (NOT a file)    fd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);    if (fd == -1)    &#123;        perror(&quot;open&quot;);        return 10;    &#125;    // extend shared memory object as by default it&#39;s initialized with size 0    res = ftruncate(fd, STORAGE_SIZE);    if (res == -1)    &#123;        perror(&quot;ftruncate&quot;);        return 20;    &#125;    // map shared memory to process address space    addr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);    if (addr == MAP_FAILED)    &#123;        perror(&quot;mmap&quot;);        return 30;    &#125;    // place data into memory    len = strlen(data) + 1;    memcpy(addr, data, len);    // wait for someone to read it    sleep(2);    // mmap cleanup    res = munmap(addr, STORAGE_SIZE);    if (res == -1)    &#123;        perror(&quot;munmap&quot;);        return 40;    &#125;    // shm_open cleanup    fd = shm_unlink(STORAGE_ID);    if (fd == -1)    &#123;        perror(&quot;unlink&quot;);        return 100;    &#125;    return 0;&#125;</code></pre><h2 id="题外话-Q-amp-A"><a href="#题外话-Q-amp-A" class="headerlink" title="题外话 Q&amp;A:"></a>题外话 Q&amp;A:</h2><h3 id="Q-mmap下的资源需要锁吗"><a href="#Q-mmap下的资源需要锁吗" class="headerlink" title="Q:mmap下的资源需要锁吗?"></a>Q:mmap下的资源需要锁吗?</h3><p>A:</p><p>需要锁:</p><p><strong>Semaphores</strong></p><p><strong>共享内存的</strong>mutex</p><p>​pthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致</p><p>如何使用?</p><p>通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息</p><p><a href="https://blog.csdn.net/qq_35396127/article/details/78942245">https://blog.csdn.net/qq_35396127/article/details/78942245</a></p><p><strong>文件锁</strong></p><p>在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust</p><h3 id="Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink"><a href="#Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink" class="headerlink" title="Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink"></a>Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink</h3><p>A:</p><p>The operation of <strong>shm_unlink</strong>() is analogous to <em><strong><a href="https://linux.die.net/man/2/unlink">unlink</a></strong>(2)</em>: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful <strong>shm_unlink</strong>(), attempts to <strong>shm_open</strong>() an object with the same <em>name</em> will fail (unless <strong>O_CREAT</strong> was specified, in which case a new, distinct object is created).</p><p>文件存在于&#x2F;dev&#x2F;shm下,如果不调用该函数,文件会一直存在</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust (Rc, RefCell) and( Arc, Mutex)</title>
      <link href="/rc_and_refcell/"/>
      <url>/rc_and_refcell/</url>
      
        <content type="html"><![CDATA[<p>Today we will introduce (<code>Rc</code>, <code>RefCell</code>) and( <code>Arc</code>, <code>Mutex</code>) In advanced Rust programming.</p><h3 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a>Rc&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p><p>Rc&lt;T&gt; is a reference counter.</p><p>T is read-only</p><h3 id="RefCell-lt-T-gt"><a href="#RefCell-lt-T-gt" class="headerlink" title="RefCell&lt;T&gt;"></a>RefCell&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p><p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data;</p><h3 id="Rc-lt-RefCell-lt-T-gt-gt"><a href="#Rc-lt-RefCell-lt-T-gt-gt" class="headerlink" title="Rc&lt;RefCell&lt;T&gt;&gt;"></a>Rc&lt;RefCell&lt;T&gt;&gt;</h3><p>only for use in single-threaded scenarios.</p><pre><code class="rust">#[derive(Debug)]enum List &#123;    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),    Nil,&#125;use crate::List::&#123;Cons, Nil&#125;;use std::cell::RefCell;use std::rc::Rc;fn main() &#123;    let value = Rc::new(RefCell::new(5));    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));    *value.borrow_mut() += 10;    println!(&quot;a after = &#123;:?&#125;&quot;, a);    println!(&quot;b after = &#123;:?&#125;&quot;, b);    println!(&quot;c after = &#123;:?&#125;&quot;, c);&#125;</code></pre><h3 id="Arc-lt-T-gt"><a href="#Arc-lt-T-gt" class="headerlink" title="Arc&lt;T&gt;"></a>Arc&lt;T&gt;</h3><p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in concurrent situations.</p><p>Arc&lt;T&gt;’s counter is atomic, So we can use it in concurrency.</p><h3 id="Mutex-lt-T-gt"><a href="#Mutex-lt-T-gt" class="headerlink" title="Mutex&lt;T&gt;"></a>Mutex&lt;T&gt;</h3><p>lock the variable access permission. thread-safe.</p><h3 id="Arc-lt-Mutex-lt-T-gt-gt"><a href="#Arc-lt-Mutex-lt-T-gt-gt" class="headerlink" title="Arc&lt;Mutex&lt;T&gt;&gt;"></a>Arc&lt;Mutex&lt;T&gt;&gt;</h3><pre><code class="rust">use std::sync::&#123;Arc, Mutex&#125;;use std::thread;fn main() &#123;    let counter = Arc::new(Mutex::new(0));    let mut handles = vec![];    for _ in 0..10 &#123;        let counter = Arc::clone(&amp;counter);        let handle = thread::spawn(move || &#123;            let mut num = counter.lock().unwrap();            *num += 1;        &#125;);        handles.push(handle);    &#125;    for handle in handles &#123;        handle.join().unwrap();    &#125;    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());&#125;</code></pre><p>don’t forget implement trait <code>Send</code> and <code>Sync</code> for T</p><pre><code class="Rust">struct X&#123;&#125;unsafe impl Sync for X&#123;&#125;unsafe impl Send for X&#123;&#125;Arc::new(Mutex::new(X::new()));</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tauri使用记录01</title>
      <link href="/First-time-to-use-tauri-ep01/"/>
      <url>/First-time-to-use-tauri-ep01/</url>
      
        <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Until 2022-09-06, both failed after trying to use Bash and Cargo to create an app. I recommend using Yarn to create the app.</p><pre><code class="bash">yarn create tauri-app</code></pre><p>choose your package manager</p><p>choose yarn</p><p>choose your front-end stack.</p><p>After finishing filling out the options, you can start the app with the command</p><pre><code class="bash">yarn tauri dev</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tech </tag>
            
            <tag> tauri </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
