---
layout: post
title: Linux的内存管理分析
date: 2022-08-31 12:00:00 +0800
last_modified_at: 2022-10-31 11:02:04 +0800
tags: [tech, Linux]
author:
author_url:
---


## 内存寻址

这是你必须掌握的东西,如果你不知道这个,后续的展开理解可能会变得困难.

让我们来看一下CPU对内存进行寻址的过程和方式.

暂无



## 虚拟内存

每个独立的进程都会拥有独立的地址空间,这就是虚拟内存.用来将虚拟地址空间映射到物理地址空间的数据结构称为页表,**每个进程均拥有独立的页表**。

什么是页表呢?

在回答这个问题前,我们需要先了解内存划分方式.

相对物理块来说，页是逻辑地址空间（**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB,32bit系统中为4KB.

在Linux下,可以通过如下命令查看页大小.

```bash
getconf PAGE_SIZE
```

物理块则是相对于**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。

> **逻辑地址到物理地址的变换过程**
>
> 1、进程访问某个逻辑地址时，分页地址机构自动将逻辑地址分为页号和页内地址
>
> 2、页号大于页表长度，越界错误
>
> 3、页表项的地址 p = 页表起始地址 F + 页号 P * 表项大小 S，从而得到对应的物理块号 B
>
> 4、页和物理块的大小是一致的，所以 页内地址=块内地址
>
> 5、然后 物理地址 = 物理块号 B * 页大小 L + 页内地址
>
> 6、根据物理地址读取数据
>
> 更加详细的说明.
>
> VA到PA的转换流程
>
> 1. 当CPU给MMU传新虚拟地址之后，MMU先去问TLB那边有没有，如果有就直接拿到物理地址发到总线给内存，开始工作
>
> 2. TLB容量比较小，难免发生Cache Miss，这时候MMU还有保底的老武器页表 Page Table，在页表中找到之后MMU除了把地址发到总线传给内存，还把这条映射关系给到TLB，让它记录一下刷新缓存
>
> 3. TLB容量不满的时候就直接把新记录存储了，当满了的时候就开启了淘汰大法LRU把旧记录清除掉，来保存新记录
>
> 4. 如果CPU给MMU的虚拟地址在TLB和Page Table都没有找到对应的物理页帧或者权限不对，该怎么办呢？即有：page fault
>
>    Page Fault：假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误；这是一个由硬件中断触发的可以由软件逻辑纠正的错误
>
>    Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。
>
>    Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其它进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。
>
>    Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。



简而言之,页表则是页地址的映射表.它记录了逻辑空间每个页在物理内存的位置.

页表常见的表现形式为一级页表,二级页表,三级页表.像Linux采用的就是四级页表.

基于32bit 系统来计算.我们来看看一级页表和二级页表的差异.

以页大小为4kb,4GB内存来计算.

一级页表:需要1M个页表项.占用4M(1M*4Byte)的地址空间.

二级页表:第一级页表1024个页表项,每个第二级页表拥有1024个页表项.占用空间为8k-4M.

二级页表的第二级页表可以是懒加载,也就是用时生成.最小满足进程运行需求的空间时1024个第一级页表+1个第二级页表.



对虚拟地址空间中不需要的区域，不必创建中间页目录或页表。与前述使 用单个数组的方法相比，多级页表节省了大量内存。

当然，该方法也有一个缺点。每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址.

CPU试图用下面两种方法加速该过程。

(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优 化了内存访问操作。

(2) 快表(TLB):地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器(Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。

## TLB原理



## TLB颠簸.

性能分析时,这是会常遇到的一个概念.

在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降，这种现象称为颠簸（抖动）；**颠簸本质上是指频繁的页调度行为**

内存颠簸的解决策略：

1. 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；
2. 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。
3. 否则，还剩下两个办法：1.终止该进程；2.增加物理内存容量；



## Others

为了权衡性能和空间,Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：

PGD： page Global directory(47-39), 页全局目录
PUD： Page Upper Directory(38-30)，页上级目录
PMD： page middle directory(29-21)，页中间目录
PTE： page table entry(20-12)，页表项

这样，一个64位的虚拟空间，就需要：2^9 个PGD + 2^9 个PUD + 2^9 个PMD + 2^9 个PTE = 2048个页表数据结构。现在的页表数据结构被扩展到了8byte。仅仅需要(2048*8=)16K就可以支持起(2^48 =)256T的进程地址空间。

参考资料:

https://zhuanlan.zhihu.com/p/37549063

https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html

