{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","path":"style/about.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","path":"style/archive.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","path":"style/base.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","path":"style/post.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","path":"style/widget-header.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","path":"style/widget-post-list.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/img_zoom.js","path":"js/img_zoom.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-3.6.1.min.js","path":"js/jquery-3.6.1.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-fancybox.min.js","path":"js/jquery-fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","path":"style/common/bulma.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","path":"style/common/helper.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","path":"style/common/variable.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/jquery.fancybox.min.css","path":"style/common/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","path":"style/themes/default-dark.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","path":"style/themes/default-light.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","path":"style/themes/highlight-theme-light.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","path":"style/themes/theme.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"15d1b2f2e2df575999c9d992abf2c547366753c2","modified":1672736943143},{"_id":"source/_posts/2022-08-31-Gossip-protocol.md","hash":"e9709a1e7e1388f53d2339198fa0783e12821d0f","modified":1672733736420},{"_id":"source/CNAME","hash":"04206fde578340018557ae46cae6da8caa822086","modified":1672733985361},{"_id":"source/_posts/2022-09-06-First-time-to-use-tauri-ep01.md","hash":"6108f84a51f89323efc2f4dd6e78132308661fce","modified":1672737008659},{"_id":"source/_posts/2022-08-31-linux-memory-manage.md","hash":"87f1fdffd115642db2c3d1295fb1d2cd81856e92","modified":1672733736421},{"_id":"source/_posts/2022-09-01-how-the-encoode-system-works.md","hash":"9d21e7c6ce70cb5d0d7f141cc89018ef9553a037","modified":1672733736422},{"_id":"source/_posts/2022-09-05-how-to-have-a-hot-pot-at-home.md","hash":"bcbee7bb883b055a421ef0fe0404c636fe347195","modified":1672733736422},{"_id":"source/_posts/2022-09-26-how-to-use-perf.md","hash":"70a51993c46d0f11fce891d53a8c3d698c499af7","modified":1672733736424},{"_id":"source/_posts/2022-09-21-mysql数据库事务详解.md","hash":"f6f2377a52a7a839147cf7104d295cf3438b16aa","modified":1672733736423},{"_id":"source/_posts/2022-09-27-booklist.md","hash":"6d675aaaa993e6212ea4f12270997f6e496232ac","modified":1672733736424},{"_id":"source/_posts/2022-10-12-a-life-of-a-process.md","hash":"37fe96ea3a50bf43d2dbddbabaa6bc257b626f0f","modified":1672733736424},{"_id":"source/_posts/2022-10-17-cpp-virtual-table.md","hash":"0b82e5e8169f34d01ac3155fe9e6b7e76c21dd3f","modified":1672733736425},{"_id":"source/_posts/2022-10-27-why-memcpy-is-faster-than-others.md","hash":"f7368b8373bfd74e8b13258de5aa9591ed513ea0","modified":1672733736426},{"_id":"source/_posts/2022-10-20-cpp-product-problems.md","hash":"be750d209d89c66672571c2f7887f631f6c17915","modified":1672733736425},{"_id":"source/_posts/2022-10-31-c_cpp_abi_problem.md","hash":"2de486704273409df1861a2ba74239d7200ec867","modified":1672733736426},{"_id":"source/_posts/2022-10-31-c_cpp_function_call_stack.md","hash":"7001561d7bbfdaf3e595ac06ba06789f8118d25a","modified":1672733736426},{"_id":"source/_posts/2022-11-09-cpp11_memory_model.md","hash":"47be4e50f9304759b5412afed4ef27bee07ced03","modified":1672733736427},{"_id":"source/_posts/2022-11-29-brpc_sourcecode_parsing_ep01.md","hash":"9255d86859374d7200780e1327823f209beac128","modified":1672733736427},{"_id":"source/_posts/2022-12-01-linux_kernel_tips.md","hash":"d6f75d95381d291ec19c7f09cdd445862b70b661","modified":1672733736428},{"_id":"source/_posts/2022-12-01-如何使用vscode优雅地阅读linux代码.md","hash":"9887c63321c6ddecfb9040e7696e3cb715b2ca64","modified":1672733736428},{"_id":"source/_posts/2022-12-15-rc_and_refcell.md","hash":"7ec9504bf79be8bca4ebbe8cb91bb0d8d72ddbbd","modified":1672733736429},{"_id":"source/_posts/2022-12-14-linux的共享内存介绍,简单使用.md","hash":"4e9ac3dcaae2217f9501b3cd4408eb102406c3e6","modified":1672733736429},{"_id":"source/_posts/2022-12-09-从Paxos,Raft等来看分布式一致性协议.md","hash":"8da5bf3e449bc4e753abe0cd1fe6fed486204448","modified":1672733736429},{"_id":"source/_posts/2023-01-03-shm-mmap.md","hash":"11363fbf6db5af5d1647e3c45545130eee2508e8","modified":1672733736430},{"_id":"source/_posts/2022-12-02-c++的不定参数传递方法.md","hash":"d1aae45c95a9cc476a7635ddf8b8f046ede36cd3","modified":1672733736428},{"_id":"themes/hexo-theme-Claudia/.gitignore","hash":"bd20d54c57507594cd16a21021c3600f9311a1f5","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/CHANGELOG.md","hash":"59b1995c016ad26343409f7ddff9f5feb75038e2","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/CONTRIBUTING.md","hash":"618215987cc9a774c37cc70efa1cb8545457a49c","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/README-CN.md","hash":"4688e3f1046585e3d7ae79f63104ed301864a240","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/LICENSE","hash":"9812afb9d0aa8596067b6fd30cf6089345b7b678","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/package.json","hash":"c59cb2089c51ed56deb2df69171d7adc63c1148f","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/CODE_OF_CONDUCT.md","hash":"787b987cd6079f93c7846b69c3b4dfa41cb3ac03","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/README.md","hash":"c6f8d7e06f79a64d18aeee6592dd44abe097cf77","modified":1672737371790},{"_id":"themes/hexo-theme-Claudia/.github/PULL_REQUEST_TEMPLATE.md","hash":"35751990a36fffe5a5f6fd682452fe5594cadde9","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/_config.yml","hash":"61a986cdca3b1d34e9ebd2d83779c91436fd3edb","modified":1672737565169},{"_id":"themes/hexo-theme-Claudia/.github/FUNDING.yml","hash":"dd672081ec4678929f6c1ac3ebbef4d990291ecd","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/languages/zh-CN.yml","hash":"dfaa6ca86d6dc041616f09e5e0b16221bdf7e122","modified":1672737371790},{"_id":"themes/hexo-theme-Claudia/languages/en.yml","hash":"66d680dcaaa2374c8a400c7266e48a4f662a9035","modified":1672737371790},{"_id":"themes/hexo-theme-Claudia/layout/archive.pug","hash":"68c709495bc39a659d9c4b19216714a5ac2b5579","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/about.pug","hash":"98dea176f76053d5deaf35ed25518d218d70be7d","modified":1672737371790},{"_id":"themes/hexo-theme-Claudia/layout/category.pug","hash":"2147f3d66640bc6604c9b15325a480d196a4df3d","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/index.pug","hash":"96b3b857b19b62823f84a164d20293cc16d891aa","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/post.pug","hash":"ebbb41aa73d3c702b983cfe740261b5b366d1145","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/tag.pug","hash":"16dac6e0a6ef939ceb6adb21dfbe0276538ff269","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/page.pug","hash":"6c5db904a03adb4794b7ada222389da12d395bc7","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/feature_request.md","hash":"9d8447814c3ac93d7fbd336015e7ef80c4a32831","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/layout/widget/base.pug","hash":"21a5eab68859adedc9997581fc54e848693c17d4","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/bug_report.md","hash":"b38365fec9b6cac6bbb75441082f041c4efd35bf","modified":1672737371789},{"_id":"themes/hexo-theme-Claudia/layout/widget/methods.pug","hash":"fa62f6ad95d1a4cda5038595d19d4d11b4b39e17","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-categories.pug","hash":"ea3bcd5f5fb06e26d8b67f30f224e7c129672980","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-header.pug","hash":"5e9b2035b31372c2bb11db6efe0e36b7df64d884","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-archives.pug","hash":"e6bcf8b09a5e06119baf3f97f7798ef7600ab65c","modified":1672737371791},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-post-list.pug","hash":"f034a4b8231f7933d06e364671b11847c74b9a5c","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-profile.pug","hash":"fbe18f3dd5e8d2850f8e6510da4fbd499d5096f0","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-search.pug","hash":"c17612dd4ae2d439d757818ec0e4215d71dd9ad5","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-recent.pug","hash":"7512dceae690ea219d562a6e450d633e29916072","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-tag.pug","hash":"714a05148758e1e3cc12635c875cb6ef1753c6ab","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-sns.pug","hash":"8ec154d321b36a5f3bf5974c75668b45ec660c1d","modified":1672737371792},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1672737371800},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","hash":"4a1beebb317c598b11fc4815e70b07bbb6d2aed7","modified":1672737371802},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","hash":"cd1dc16dfa7c482cc88ddabaf8c9a459299a98cf","modified":1672737371802},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","hash":"18782c2ab206abbeb0ee59632864251acfd20d85","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","hash":"8a3520a0ceb22a2fde35b09485e2df6dd5a23b6f","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","hash":"da7457c952b6b433f273d7ecc562d24dcd4aa431","modified":1672737371802},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","hash":"53ea5dc4fb868f3553a5c117e528082ba3c7961c","modified":1672737371804},{"_id":"themes/hexo-theme-Claudia/source/js/img_zoom.js","hash":"a384c3a60fcbdad813cb8340200dfb07ebbcc48c","modified":1672737371801},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","hash":"7f62c8c148ee0b528a2bea47b248b2a7f5501142","modified":1672737371800},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","hash":"04edd583f103ba444d8174d55e7f45e27b8f2549","modified":1672737371802},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","hash":"7cd0982fe839e760523f8f85ea6f06f2b5d2111a","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","hash":"fffe6eacfa4d814626a1e1d84dc651233eded060","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/common/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","hash":"0cbdc5738503f55e5b84e1bd00e445c98c7d56d2","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","hash":"23e7c1f87e252db80d34d36a2129e98dde7b1b55","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","hash":"caf7517c9200bbf7152a7f5edba4298fbf9ae629","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/img.png","hash":"2239d04aa7d31850b024d3ccac609fbf9dcb98d2","modified":1672737371790},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","hash":"2ef9bbbc688ce413686ce0eb64d0b25af4ea34e2","modified":1672737371801},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-3.6.1.min.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1672737371801},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1672737371801},{"_id":"themes/hexo-theme-Claudia/screenshot/BuyMeCoffeeQRCode.png","hash":"df14bf998f23f9e8a323e2d79802e887875c8842","modified":1672737371793},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1672737371803},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover.png","hash":"757680cd3648e3569d6a18abaf33180dc427d620","modified":1672737371800},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover-v2.png","hash":"f477d90d327a638a46b3caa172332e931955a532","modified":1672737371797}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"Gossip Protocol[TODO]","date":"2022-08-31T04:00:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"说明:\n\nGossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。\n\n\n\n","source":"_posts/2022-08-31-Gossip-protocol.md","raw":"---\nlayout: post\ntitle: Gossip Protocol[TODO]\ndate: 2022-08-31 12:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [tech, mysql]\nauthor: fakecore\nauthor_url:\n---\n说明:\n\nGossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。\n\n\n\n","slug":"Gossip-protocol","published":1,"updated":"2023-01-03T08:15:36.420Z","comments":1,"photos":[],"link":"","_id":"clcg0w03s00007dt3apqp20n5","content":"<p>说明:</p>\n<p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>说明:</p>\n<p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p>\n"},{"layout":"post","title":"Linux的内存管理分析","date":"2022-08-31T04:00:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":null,"author_url":null,"_content":"\n\n## 内存寻址\n\n这是你必须掌握的东西,如果你不知道这个,后续的展开理解可能会变得困难.\n\n让我们来看一下CPU对内存进行寻址的过程和方式.\n\n暂无\n\n\n\n## 虚拟内存\n\n每个独立的进程都会拥有独立的地址空间,这就是虚拟内存.用来将虚拟地址空间映射到物理地址空间的数据结构称为页表,**每个进程均拥有独立的页表**。\n\n什么是页表呢?\n\n在回答这个问题前,我们需要先了解内存划分方式.\n\n相对物理块来说，页是逻辑地址空间（**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB,32bit系统中为4KB.\n\n在Linux下,可以通过如下命令查看页大小.\n\n```bash\ngetconf PAGE_SIZE\n```\n\n物理块则是相对于**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。\n\n> **逻辑地址到物理地址的变换过程**\n>\n> 1、进程访问某个逻辑地址时，分页地址机构自动将逻辑地址分为页号和页内地址\n>\n> 2、页号大于页表长度，越界错误\n>\n> 3、页表项的地址 p = 页表起始地址 F + 页号 P * 表项大小 S，从而得到对应的物理块号 B\n>\n> 4、页和物理块的大小是一致的，所以 页内地址=块内地址\n>\n> 5、然后 物理地址 = 物理块号 B * 页大小 L + 页内地址\n>\n> 6、根据物理地址读取数据\n>\n> 更加详细的说明.\n>\n> VA到PA的转换流程\n>\n> 1. 当CPU给MMU传新虚拟地址之后，MMU先去问TLB那边有没有，如果有就直接拿到物理地址发到总线给内存，开始工作\n>\n> 2. TLB容量比较小，难免发生Cache Miss，这时候MMU还有保底的老武器页表 Page Table，在页表中找到之后MMU除了把地址发到总线传给内存，还把这条映射关系给到TLB，让它记录一下刷新缓存\n>\n> 3. TLB容量不满的时候就直接把新记录存储了，当满了的时候就开启了淘汰大法LRU把旧记录清除掉，来保存新记录\n>\n> 4. 如果CPU给MMU的虚拟地址在TLB和Page Table都没有找到对应的物理页帧或者权限不对，该怎么办呢？即有：page fault\n>\n>    Page Fault：假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误；这是一个由硬件中断触发的可以由软件逻辑纠正的错误\n>\n>    Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。\n>\n>    Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其它进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。\n>\n>    Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。\n\n\n\n简而言之,页表则是页地址的映射表.它记录了逻辑空间每个页在物理内存的位置.\n\n页表常见的表现形式为一级页表,二级页表,三级页表.像Linux采用的就是四级页表.\n\n基于32bit 系统来计算.我们来看看一级页表和二级页表的差异.\n\n以页大小为4kb,4GB内存来计算.\n\n一级页表:需要1M个页表项.占用4M(1M*4Byte)的地址空间.\n\n二级页表:第一级页表1024个页表项,每个第二级页表拥有1024个页表项.占用空间为8k-4M.\n\n二级页表的第二级页表可以是懒加载,也就是用时生成.最小满足进程运行需求的空间时1024个第一级页表+1个第二级页表.\n\n\n\n对虚拟地址空间中不需要的区域，不必创建中间页目录或页表。与前述使 用单个数组的方法相比，多级页表节省了大量内存。\n\n当然，该方法也有一个缺点。每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址.\n\nCPU试图用下面两种方法加速该过程。\n\n(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优 化了内存访问操作。\n\n(2) 快表(TLB):地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器(Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。\n\n## TLB原理\n\n\n\n## TLB颠簸.\n\n性能分析时,这是会常遇到的一个概念.\n\n在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降，这种现象称为颠簸（抖动）；**颠簸本质上是指频繁的页调度行为**\n\n内存颠簸的解决策略：\n\n1. 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；\n2. 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。\n3. 否则，还剩下两个办法：1.终止该进程；2.增加物理内存容量；\n\n\n\n## Others\n\n为了权衡性能和空间,Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：\n\nPGD： page Global directory(47-39), 页全局目录\nPUD： Page Upper Directory(38-30)，页上级目录\nPMD： page middle directory(29-21)，页中间目录\nPTE： page table entry(20-12)，页表项\n\n这样，一个64位的虚拟空间，就需要：2^9 个PGD + 2^9 个PUD + 2^9 个PMD + 2^9 个PTE = 2048个页表数据结构。现在的页表数据结构被扩展到了8byte。仅仅需要(2048*8=)16K就可以支持起(2^48 =)256T的进程地址空间。\n\n参考资料:\n\nhttps://zhuanlan.zhihu.com/p/37549063\n\nhttps://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html\n\n","source":"_posts/2022-08-31-linux-memory-manage.md","raw":"---\nlayout: post\ntitle: Linux的内存管理分析\ndate: 2022-08-31 12:00:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [tech, Linux]\nauthor:\nauthor_url:\n---\n\n\n## 内存寻址\n\n这是你必须掌握的东西,如果你不知道这个,后续的展开理解可能会变得困难.\n\n让我们来看一下CPU对内存进行寻址的过程和方式.\n\n暂无\n\n\n\n## 虚拟内存\n\n每个独立的进程都会拥有独立的地址空间,这就是虚拟内存.用来将虚拟地址空间映射到物理地址空间的数据结构称为页表,**每个进程均拥有独立的页表**。\n\n什么是页表呢?\n\n在回答这个问题前,我们需要先了解内存划分方式.\n\n相对物理块来说，页是逻辑地址空间（**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB,32bit系统中为4KB.\n\n在Linux下,可以通过如下命令查看页大小.\n\n```bash\ngetconf PAGE_SIZE\n```\n\n物理块则是相对于**[虚拟内存](https://link.zhihu.com/?target=http%3A//www.tomorrow.wiki/tag/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98/)**对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。\n\n> **逻辑地址到物理地址的变换过程**\n>\n> 1、进程访问某个逻辑地址时，分页地址机构自动将逻辑地址分为页号和页内地址\n>\n> 2、页号大于页表长度，越界错误\n>\n> 3、页表项的地址 p = 页表起始地址 F + 页号 P * 表项大小 S，从而得到对应的物理块号 B\n>\n> 4、页和物理块的大小是一致的，所以 页内地址=块内地址\n>\n> 5、然后 物理地址 = 物理块号 B * 页大小 L + 页内地址\n>\n> 6、根据物理地址读取数据\n>\n> 更加详细的说明.\n>\n> VA到PA的转换流程\n>\n> 1. 当CPU给MMU传新虚拟地址之后，MMU先去问TLB那边有没有，如果有就直接拿到物理地址发到总线给内存，开始工作\n>\n> 2. TLB容量比较小，难免发生Cache Miss，这时候MMU还有保底的老武器页表 Page Table，在页表中找到之后MMU除了把地址发到总线传给内存，还把这条映射关系给到TLB，让它记录一下刷新缓存\n>\n> 3. TLB容量不满的时候就直接把新记录存储了，当满了的时候就开启了淘汰大法LRU把旧记录清除掉，来保存新记录\n>\n> 4. 如果CPU给MMU的虚拟地址在TLB和Page Table都没有找到对应的物理页帧或者权限不对，该怎么办呢？即有：page fault\n>\n>    Page Fault：假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误；这是一个由硬件中断触发的可以由软件逻辑纠正的错误\n>\n>    Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。\n>\n>    Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其它进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。\n>\n>    Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。\n\n\n\n简而言之,页表则是页地址的映射表.它记录了逻辑空间每个页在物理内存的位置.\n\n页表常见的表现形式为一级页表,二级页表,三级页表.像Linux采用的就是四级页表.\n\n基于32bit 系统来计算.我们来看看一级页表和二级页表的差异.\n\n以页大小为4kb,4GB内存来计算.\n\n一级页表:需要1M个页表项.占用4M(1M*4Byte)的地址空间.\n\n二级页表:第一级页表1024个页表项,每个第二级页表拥有1024个页表项.占用空间为8k-4M.\n\n二级页表的第二级页表可以是懒加载,也就是用时生成.最小满足进程运行需求的空间时1024个第一级页表+1个第二级页表.\n\n\n\n对虚拟地址空间中不需要的区域，不必创建中间页目录或页表。与前述使 用单个数组的方法相比，多级页表节省了大量内存。\n\n当然，该方法也有一个缺点。每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址.\n\nCPU试图用下面两种方法加速该过程。\n\n(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优 化了内存访问操作。\n\n(2) 快表(TLB):地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器(Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。\n\n## TLB原理\n\n\n\n## TLB颠簸.\n\n性能分析时,这是会常遇到的一个概念.\n\n在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降，这种现象称为颠簸（抖动）；**颠簸本质上是指频繁的页调度行为**\n\n内存颠簸的解决策略：\n\n1. 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；\n2. 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。\n3. 否则，还剩下两个办法：1.终止该进程；2.增加物理内存容量；\n\n\n\n## Others\n\n为了权衡性能和空间,Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：\n\nPGD： page Global directory(47-39), 页全局目录\nPUD： Page Upper Directory(38-30)，页上级目录\nPMD： page middle directory(29-21)，页中间目录\nPTE： page table entry(20-12)，页表项\n\n这样，一个64位的虚拟空间，就需要：2^9 个PGD + 2^9 个PUD + 2^9 个PMD + 2^9 个PTE = 2048个页表数据结构。现在的页表数据结构被扩展到了8byte。仅仅需要(2048*8=)16K就可以支持起(2^48 =)256T的进程地址空间。\n\n参考资料:\n\nhttps://zhuanlan.zhihu.com/p/37549063\n\nhttps://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html\n\n","slug":"linux-memory-manage","published":1,"updated":"2023-01-03T08:15:36.421Z","comments":1,"photos":[],"link":"","_id":"clcg0w03v00017dt37w1304ki","content":"<h2 id=\"内存寻址\"><a href=\"#内存寻址\" class=\"headerlink\" title=\"内存寻址\"></a>内存寻址</h2><p>这是你必须掌握的东西,如果你不知道这个,后续的展开理解可能会变得困难.</p>\n<p>让我们来看一下CPU对内存进行寻址的过程和方式.</p>\n<p>暂无</p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>每个独立的进程都会拥有独立的地址空间,这就是虚拟内存.用来将虚拟地址空间映射到物理地址空间的数据结构称为页表,<strong>每个进程均拥有独立的页表</strong>。</p>\n<p>什么是页表呢?</p>\n<p>在回答这个问题前,我们需要先了解内存划分方式.</p>\n<p>相对物理块来说，页是逻辑地址空间（**<a href=\"https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/\">虚拟内存</a>**空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB,32bit系统中为4KB.</p>\n<p>在Linux下,可以通过如下命令查看页大小.</p>\n<pre><code class=\"bash\">getconf PAGE_SIZE\n</code></pre>\n<p>物理块则是相对于**<a href=\"https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/\">虚拟内存</a>**对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。</p>\n<blockquote>\n<p><strong>逻辑地址到物理地址的变换过程</strong></p>\n<p>1、进程访问某个逻辑地址时，分页地址机构自动将逻辑地址分为页号和页内地址</p>\n<p>2、页号大于页表长度，越界错误</p>\n<p>3、页表项的地址 p &#x3D; 页表起始地址 F + 页号 P * 表项大小 S，从而得到对应的物理块号 B</p>\n<p>4、页和物理块的大小是一致的，所以 页内地址&#x3D;块内地址</p>\n<p>5、然后 物理地址 &#x3D; 物理块号 B * 页大小 L + 页内地址</p>\n<p>6、根据物理地址读取数据</p>\n<p>更加详细的说明.</p>\n<p>VA到PA的转换流程</p>\n<ol>\n<li><p>当CPU给MMU传新虚拟地址之后，MMU先去问TLB那边有没有，如果有就直接拿到物理地址发到总线给内存，开始工作</p>\n</li>\n<li><p>TLB容量比较小，难免发生Cache Miss，这时候MMU还有保底的老武器页表 Page Table，在页表中找到之后MMU除了把地址发到总线传给内存，还把这条映射关系给到TLB，让它记录一下刷新缓存</p>\n</li>\n<li><p>TLB容量不满的时候就直接把新记录存储了，当满了的时候就开启了淘汰大法LRU把旧记录清除掉，来保存新记录</p>\n</li>\n<li><p>如果CPU给MMU的虚拟地址在TLB和Page Table都没有找到对应的物理页帧或者权限不对，该怎么办呢？即有：page fault</p>\n<p>Page Fault：假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误；这是一个由硬件中断触发的可以由软件逻辑纠正的错误</p>\n<p>Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误&#x2F;主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。</p>\n<p>Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误&#x2F;次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其它进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。</p>\n<p>Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。</p>\n</li>\n</ol>\n</blockquote>\n<p>简而言之,页表则是页地址的映射表.它记录了逻辑空间每个页在物理内存的位置.</p>\n<p>页表常见的表现形式为一级页表,二级页表,三级页表.像Linux采用的就是四级页表.</p>\n<p>基于32bit 系统来计算.我们来看看一级页表和二级页表的差异.</p>\n<p>以页大小为4kb,4GB内存来计算.</p>\n<p>一级页表:需要1M个页表项.占用4M(1M*4Byte)的地址空间.</p>\n<p>二级页表:第一级页表1024个页表项,每个第二级页表拥有1024个页表项.占用空间为8k-4M.</p>\n<p>二级页表的第二级页表可以是懒加载,也就是用时生成.最小满足进程运行需求的空间时1024个第一级页表+1个第二级页表.</p>\n<p>对虚拟地址空间中不需要的区域，不必创建中间页目录或页表。与前述使 用单个数组的方法相比，多级页表节省了大量内存。</p>\n<p>当然，该方法也有一个缺点。每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址.</p>\n<p>CPU试图用下面两种方法加速该过程。</p>\n<p>(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优 化了内存访问操作。</p>\n<p>(2) 快表(TLB):地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器(Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。</p>\n<h2 id=\"TLB原理\"><a href=\"#TLB原理\" class=\"headerlink\" title=\"TLB原理\"></a>TLB原理</h2><h2 id=\"TLB颠簸\"><a href=\"#TLB颠簸\" class=\"headerlink\" title=\"TLB颠簸.\"></a>TLB颠簸.</h2><p>性能分析时,这是会常遇到的一个概念.</p>\n<p>在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降，这种现象称为颠簸（抖动）；<strong>颠簸本质上是指频繁的页调度行为</strong></p>\n<p>内存颠簸的解决策略：</p>\n<ol>\n<li>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</li>\n<li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。</li>\n<li>否则，还剩下两个办法：1.终止该进程；2.增加物理内存容量；</li>\n</ol>\n<h2 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h2><p>为了权衡性能和空间,Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：</p>\n<p>PGD： page Global directory(47-39), 页全局目录<br>PUD： Page Upper Directory(38-30)，页上级目录<br>PMD： page middle directory(29-21)，页中间目录<br>PTE： page table entry(20-12)，页表项</p>\n<p>这样，一个64位的虚拟空间，就需要：2^9 个PGD + 2^9 个PUD + 2^9 个PMD + 2^9 个PTE &#x3D; 2048个页表数据结构。现在的页表数据结构被扩展到了8byte。仅仅需要(2048*8&#x3D;)16K就可以支持起(2^48 &#x3D;)256T的进程地址空间。</p>\n<p>参考资料:</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/37549063\">https://zhuanlan.zhihu.com/p/37549063</a></p>\n<p><a href=\"https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html\">https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存寻址\"><a href=\"#内存寻址\" class=\"headerlink\" title=\"内存寻址\"></a>内存寻址</h2><p>这是你必须掌握的东西,如果你不知道这个,后续的展开理解可能会变得困难.</p>\n<p>让我们来看一下CPU对内存进行寻址的过程和方式.</p>\n<p>暂无</p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>每个独立的进程都会拥有独立的地址空间,这就是虚拟内存.用来将虚拟地址空间映射到物理地址空间的数据结构称为页表,<strong>每个进程均拥有独立的页表</strong>。</p>\n<p>什么是页表呢?</p>\n<p>在回答这个问题前,我们需要先了解内存划分方式.</p>\n<p>相对物理块来说，页是逻辑地址空间（**<a href=\"https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/\">虚拟内存</a>**空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB,32bit系统中为4KB.</p>\n<p>在Linux下,可以通过如下命令查看页大小.</p>\n<pre><code class=\"bash\">getconf PAGE_SIZE\n</code></pre>\n<p>物理块则是相对于**<a href=\"https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/\">虚拟内存</a>**对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。</p>\n<blockquote>\n<p><strong>逻辑地址到物理地址的变换过程</strong></p>\n<p>1、进程访问某个逻辑地址时，分页地址机构自动将逻辑地址分为页号和页内地址</p>\n<p>2、页号大于页表长度，越界错误</p>\n<p>3、页表项的地址 p &#x3D; 页表起始地址 F + 页号 P * 表项大小 S，从而得到对应的物理块号 B</p>\n<p>4、页和物理块的大小是一致的，所以 页内地址&#x3D;块内地址</p>\n<p>5、然后 物理地址 &#x3D; 物理块号 B * 页大小 L + 页内地址</p>\n<p>6、根据物理地址读取数据</p>\n<p>更加详细的说明.</p>\n<p>VA到PA的转换流程</p>\n<ol>\n<li><p>当CPU给MMU传新虚拟地址之后，MMU先去问TLB那边有没有，如果有就直接拿到物理地址发到总线给内存，开始工作</p>\n</li>\n<li><p>TLB容量比较小，难免发生Cache Miss，这时候MMU还有保底的老武器页表 Page Table，在页表中找到之后MMU除了把地址发到总线传给内存，还把这条映射关系给到TLB，让它记录一下刷新缓存</p>\n</li>\n<li><p>TLB容量不满的时候就直接把新记录存储了，当满了的时候就开启了淘汰大法LRU把旧记录清除掉，来保存新记录</p>\n</li>\n<li><p>如果CPU给MMU的虚拟地址在TLB和Page Table都没有找到对应的物理页帧或者权限不对，该怎么办呢？即有：page fault</p>\n<p>Page Fault：假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误；这是一个由硬件中断触发的可以由软件逻辑纠正的错误</p>\n<p>Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误&#x2F;主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射。</p>\n<p>Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误&#x2F;次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其它进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。</p>\n<p>Invalid Page Fault 翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。</p>\n</li>\n</ol>\n</blockquote>\n<p>简而言之,页表则是页地址的映射表.它记录了逻辑空间每个页在物理内存的位置.</p>\n<p>页表常见的表现形式为一级页表,二级页表,三级页表.像Linux采用的就是四级页表.</p>\n<p>基于32bit 系统来计算.我们来看看一级页表和二级页表的差异.</p>\n<p>以页大小为4kb,4GB内存来计算.</p>\n<p>一级页表:需要1M个页表项.占用4M(1M*4Byte)的地址空间.</p>\n<p>二级页表:第一级页表1024个页表项,每个第二级页表拥有1024个页表项.占用空间为8k-4M.</p>\n<p>二级页表的第二级页表可以是懒加载,也就是用时生成.最小满足进程运行需求的空间时1024个第一级页表+1个第二级页表.</p>\n<p>对虚拟地址空间中不需要的区域，不必创建中间页目录或页表。与前述使 用单个数组的方法相比，多级页表节省了大量内存。</p>\n<p>当然，该方法也有一个缺点。每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址.</p>\n<p>CPU试图用下面两种方法加速该过程。</p>\n<p>(1) CPU中有一个专门的部分称为MMU(Memory Management Unit，内存管理单元)，该单元优 化了内存访问操作。</p>\n<p>(2) 快表(TLB):地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器(Translation Lookaside Buffer，TLB)的CPU高速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据，因而 大大加速了地址转换。</p>\n<h2 id=\"TLB原理\"><a href=\"#TLB原理\" class=\"headerlink\" title=\"TLB原理\"></a>TLB原理</h2><h2 id=\"TLB颠簸\"><a href=\"#TLB颠簸\" class=\"headerlink\" title=\"TLB颠簸.\"></a>TLB颠簸.</h2><p>性能分析时,这是会常遇到的一个概念.</p>\n<p>在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降，这种现象称为颠簸（抖动）；<strong>颠簸本质上是指频繁的页调度行为</strong></p>\n<p>内存颠簸的解决策略：</p>\n<ol>\n<li>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</li>\n<li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。</li>\n<li>否则，还剩下两个办法：1.终止该进程；2.增加物理内存容量；</li>\n</ol>\n<h2 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h2><p>为了权衡性能和空间,Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：</p>\n<p>PGD： page Global directory(47-39), 页全局目录<br>PUD： Page Upper Directory(38-30)，页上级目录<br>PMD： page middle directory(29-21)，页中间目录<br>PTE： page table entry(20-12)，页表项</p>\n<p>这样，一个64位的虚拟空间，就需要：2^9 个PGD + 2^9 个PUD + 2^9 个PMD + 2^9 个PTE &#x3D; 2048个页表数据结构。现在的页表数据结构被扩展到了8byte。仅仅需要(2048*8&#x3D;)16K就可以支持起(2^48 &#x3D;)256T的进程地址空间。</p>\n<p>参考资料:</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/37549063\">https://zhuanlan.zhihu.com/p/37549063</a></p>\n<p><a href=\"https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html\">https://dreamgoing.github.io/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</a></p>\n"},{"layout":"post","title":"不同字符集编码原理[TODO]","date":"2022-09-01T04:00:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":null,"author_url":null,"_content":"","source":"_posts/2022-09-01-how-the-encoode-system-works.md","raw":"---\nlayout: post\ntitle: 不同字符集编码原理[TODO]\ndate: 2022-09-01 12:00:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [tech]\nauthor:\nauthor_url:\n---","slug":"how-the-encoode-system-works","published":1,"updated":"2023-01-03T08:15:36.422Z","comments":1,"photos":[],"link":"","_id":"clcg0w03w00037dt3burc1sb5","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"","date":"2022-09-05T04:00:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":null,"author_url":null,"_content":"It's a guide for those who love hot pot but think it's expensive to go to a restaurant and want to make it at home.\n\n## Step One\n\nMaterial Prepare:\n\n1. Hot Pot Spicy Sause (1 Pack)\n2. A dual-sided(one-sided is ok too) soup cookware\n3. A cooked pork bone soup(boiled water is also good), remember, it needs hot water If u don't want to wait for the reboil.\n4. Some kinds of seafood, meats, vegetables\n\n## Step Two\n\nlet's cook it at home.\n\n","source":"_posts/2022-09-05-how-to-have-a-hot-pot-at-home.md","raw":"---\nlayout: post\ntitle:\ndate: 2022-09-05 12:00:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [life]\nauthor:\nauthor_url:\n---\nIt's a guide for those who love hot pot but think it's expensive to go to a restaurant and want to make it at home.\n\n## Step One\n\nMaterial Prepare:\n\n1. Hot Pot Spicy Sause (1 Pack)\n2. A dual-sided(one-sided is ok too) soup cookware\n3. A cooked pork bone soup(boiled water is also good), remember, it needs hot water If u don't want to wait for the reboil.\n4. Some kinds of seafood, meats, vegetables\n\n## Step Two\n\nlet's cook it at home.\n\n","slug":"how-to-have-a-hot-pot-at-home","published":1,"updated":"2023-01-03T08:15:36.422Z","comments":1,"photos":[],"link":"","_id":"clcg0w03x00047dt3d6jhdvey","content":"<p>It’s a guide for those who love hot pot but think it’s expensive to go to a restaurant and want to make it at home.</p>\n<h2 id=\"Step-One\"><a href=\"#Step-One\" class=\"headerlink\" title=\"Step One\"></a>Step One</h2><p>Material Prepare:</p>\n<ol>\n<li>Hot Pot Spicy Sause (1 Pack)</li>\n<li>A dual-sided(one-sided is ok too) soup cookware</li>\n<li>A cooked pork bone soup(boiled water is also good), remember, it needs hot water If u don’t want to wait for the reboil.</li>\n<li>Some kinds of seafood, meats, vegetables</li>\n</ol>\n<h2 id=\"Step-Two\"><a href=\"#Step-Two\" class=\"headerlink\" title=\"Step Two\"></a>Step Two</h2><p>let’s cook it at home.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>It’s a guide for those who love hot pot but think it’s expensive to go to a restaurant and want to make it at home.</p>\n<h2 id=\"Step-One\"><a href=\"#Step-One\" class=\"headerlink\" title=\"Step One\"></a>Step One</h2><p>Material Prepare:</p>\n<ol>\n<li>Hot Pot Spicy Sause (1 Pack)</li>\n<li>A dual-sided(one-sided is ok too) soup cookware</li>\n<li>A cooked pork bone soup(boiled water is also good), remember, it needs hot water If u don’t want to wait for the reboil.</li>\n<li>Some kinds of seafood, meats, vegetables</li>\n</ol>\n<h2 id=\"Step-Two\"><a href=\"#Step-Two\" class=\"headerlink\" title=\"Step Two\"></a>Step Two</h2><p>let’s cook it at home.</p>\n"},{"_content":"---\nlayout:post\ntitle:tauri使用记录01[TODO]\ndate:2022-09-06 12:00:00 +0800\nlast_modified_at:2022-12-16 17:21:05 +0800\ntags:[tech,tauri]\nauthor:fakecore\n---\n\n## Installation\n\nUntil 2022-09-06, both failed after trying to use Bash and Cargo to create an app. I recommend using Yarn to create the app.\n\n```bash\nyarn create tauri-app\n```\n\nchoose your package manager\n\nchoose yarn\n\nchoose your front-end stack.\n\nAfter finishing filling out the options, you can start the app with the command\n\n```bash\nyarn tauri dev\n```\n\n","source":"_posts/2022-09-06-First-time-to-use-tauri-ep01.md","raw":"---\nlayout:post\ntitle:tauri使用记录01[TODO]\ndate:2022-09-06 12:00:00 +0800\nlast_modified_at:2022-12-16 17:21:05 +0800\ntags:[tech,tauri]\nauthor:fakecore\n---\n\n## Installation\n\nUntil 2022-09-06, both failed after trying to use Bash and Cargo to create an app. I recommend using Yarn to create the app.\n\n```bash\nyarn create tauri-app\n```\n\nchoose your package manager\n\nchoose yarn\n\nchoose your front-end stack.\n\nAfter finishing filling out the options, you can start the app with the command\n\n```bash\nyarn tauri dev\n```\n\n","slug":"First-time-to-use-tauri-ep01","published":1,"date":"2022-09-05T16:00:00.000Z","updated":"2023-01-03T09:10:08.659Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clcg0w03x00057dt3g8f630yd","content":"<hr>\n<h2 id=\"layout-posttitle-tauri使用记录01-TODO-date-2022-09-06-12-00-00-0800last-modified-at-2022-12-16-17-21-05-0800tags-tech-tauri-author-fakecore\"><a href=\"#layout-posttitle-tauri使用记录01-TODO-date-2022-09-06-12-00-00-0800last-modified-at-2022-12-16-17-21-05-0800tags-tech-tauri-author-fakecore\" class=\"headerlink\" title=\"layout:posttitle:tauri使用记录01[TODO]date:2022-09-06 12:00:00 +0800last_modified_at:2022-12-16 17:21:05 +0800tags:[tech,tauri]author:fakecore\"></a>layout:post<br>title:tauri使用记录01[TODO]<br>date:2022-09-06 12:00:00 +0800<br>last_modified_at:2022-12-16 17:21:05 +0800<br>tags:[tech,tauri]<br>author:fakecore</h2><h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Until 2022-09-06, both failed after trying to use Bash and Cargo to create an app. I recommend using Yarn to create the app.</p>\n<pre><code class=\"bash\">yarn create tauri-app\n</code></pre>\n<p>choose your package manager</p>\n<p>choose yarn</p>\n<p>choose your front-end stack.</p>\n<p>After finishing filling out the options, you can start the app with the command</p>\n<pre><code class=\"bash\">yarn tauri dev\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"layout-posttitle-tauri使用记录01-TODO-date-2022-09-06-12-00-00-0800last-modified-at-2022-12-16-17-21-05-0800tags-tech-tauri-author-fakecore\"><a href=\"#layout-posttitle-tauri使用记录01-TODO-date-2022-09-06-12-00-00-0800last-modified-at-2022-12-16-17-21-05-0800tags-tech-tauri-author-fakecore\" class=\"headerlink\" title=\"layout:posttitle:tauri使用记录01[TODO]date:2022-09-06 12:00:00 +0800last_modified_at:2022-12-16 17:21:05 +0800tags:[tech,tauri]author:fakecore\"></a>layout:post<br>title:tauri使用记录01[TODO]<br>date:2022-09-06 12:00:00 +0800<br>last_modified_at:2022-12-16 17:21:05 +0800<br>tags:[tech,tauri]<br>author:fakecore</h2><h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Until 2022-09-06, both failed after trying to use Bash and Cargo to create an app. I recommend using Yarn to create the app.</p>\n<pre><code class=\"bash\">yarn create tauri-app\n</code></pre>\n<p>choose your package manager</p>\n<p>choose yarn</p>\n<p>choose your front-end stack.</p>\n<p>After finishing filling out the options, you can start the app with the command</p>\n<pre><code class=\"bash\">yarn tauri dev\n</code></pre>\n"},{"layout":"post","title":"mysql数据库事务详解","date":"2022-09-21T08:00:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":"https://fakecore","_content":"\n今天就来介绍下mysql的事务相关知识\n\n名词介绍\n\n| 事务等级                          | 脏读                                                         | 不可重复读                                                   | 幻读 |      | 备注 |\n| :-------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | ---- | ---- |\n| Read uncommitted                  | ✔︎                                                            | ✔                                                            | ✔    |      |      |\n| Read commited                     | ✗                                                            | ✔                                                            | ✔    |      |      |\n| Repeatable read                   | ✗                                                            | ✗                                                            | ✔    |      |      |\n| Serializable                      | ✗                                                            | ✗                                                            | ✗    |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n| for update                        | 对于搜索遇到的索引记录,锁定这行以及任何相关联的索引入口,这与`update`语句功能相似.其他事物如果在更新或者执行`select ... for share`,又或者是基于确定的事务隔离等级去读取数据,这些操作都会被堵塞.一致读取忽略读取视图中存在的记录上设置的任何锁 | For index records the search encounters, locks the rows and any associated index entries, the same as if you issued an `UPDATE` statement for those rows. Other transactions are blocked from updating those rows, from doing `SELECT ... FOR SHARE`, or from reading the data in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view. (Old versions of a record cannot be locked; they are reconstructed by applying [undo logs](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log) on an in-memory copy of the record.) |      |      |      |\n| LOCK IN SHARE MODE/FOR SHARE(8.0) | 在被读取的任意行上设置share mode 锁.其他会话可以读取这些行,如果要修改必须等到会话提交.如果这些行被其他事务修改但是还没提交话,你的请求等待到事务结束,并且使用最新值 | Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values. |      |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n\n\n\n\n\n\n\n","source":"_posts/2022-09-21-mysql数据库事务详解.md","raw":"---\nlayout: post\ntitle: mysql数据库事务详解\ndate: 2022-09-21 16:00:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [tech, mysql]\nauthor: fakecore\nauthor_url: https://fakecore\n---\n\n今天就来介绍下mysql的事务相关知识\n\n名词介绍\n\n| 事务等级                          | 脏读                                                         | 不可重复读                                                   | 幻读 |      | 备注 |\n| :-------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | ---- | ---- |\n| Read uncommitted                  | ✔︎                                                            | ✔                                                            | ✔    |      |      |\n| Read commited                     | ✗                                                            | ✔                                                            | ✔    |      |      |\n| Repeatable read                   | ✗                                                            | ✗                                                            | ✔    |      |      |\n| Serializable                      | ✗                                                            | ✗                                                            | ✗    |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n| for update                        | 对于搜索遇到的索引记录,锁定这行以及任何相关联的索引入口,这与`update`语句功能相似.其他事物如果在更新或者执行`select ... for share`,又或者是基于确定的事务隔离等级去读取数据,这些操作都会被堵塞.一致读取忽略读取视图中存在的记录上设置的任何锁 | For index records the search encounters, locks the rows and any associated index entries, the same as if you issued an `UPDATE` statement for those rows. Other transactions are blocked from updating those rows, from doing `SELECT ... FOR SHARE`, or from reading the data in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view. (Old versions of a record cannot be locked; they are reconstructed by applying [undo logs](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log) on an in-memory copy of the record.) |      |      |      |\n| LOCK IN SHARE MODE/FOR SHARE(8.0) | 在被读取的任意行上设置share mode 锁.其他会话可以读取这些行,如果要修改必须等到会话提交.如果这些行被其他事务修改但是还没提交话,你的请求等待到事务结束,并且使用最新值 | Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values. |      |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n|                                   |                                                              |                                                              |      |      |      |\n\n\n\n\n\n\n\n","slug":"mysql数据库事务详解","published":1,"updated":"2023-01-03T08:15:36.423Z","comments":1,"photos":[],"link":"","_id":"clcg0w03y00077dt3fgyi6pb3","content":"<p>今天就来介绍下mysql的事务相关知识</p>\n<p>名词介绍</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">事务等级</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th></th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Read uncommitted</td>\n<td>✔︎</td>\n<td>✔</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Read commited</td>\n<td>✗</td>\n<td>✔</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Repeatable read</td>\n<td>✗</td>\n<td>✗</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Serializable</td>\n<td>✗</td>\n<td>✗</td>\n<td>✗</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">for update</td>\n<td>对于搜索遇到的索引记录,锁定这行以及任何相关联的索引入口,这与<code>update</code>语句功能相似.其他事物如果在更新或者执行<code>select ... for share</code>,又或者是基于确定的事务隔离等级去读取数据,这些操作都会被堵塞.一致读取忽略读取视图中存在的记录上设置的任何锁</td>\n<td>For index records the search encounters, locks the rows and any associated index entries, the same as if you issued an <code>UPDATE</code> statement for those rows. Other transactions are blocked from updating those rows, from doing <code>SELECT ... FOR SHARE</code>, or from reading the data in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view. (Old versions of a record cannot be locked; they are reconstructed by applying <a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log\">undo logs</a> on an in-memory copy of the record.)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">LOCK IN SHARE MODE&#x2F;FOR SHARE(8.0)</td>\n<td>在被读取的任意行上设置share mode 锁.其他会话可以读取这些行,如果要修改必须等到会话提交.如果这些行被其他事务修改但是还没提交话,你的请求等待到事务结束,并且使用最新值</td>\n<td>Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>今天就来介绍下mysql的事务相关知识</p>\n<p>名词介绍</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">事务等级</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th></th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Read uncommitted</td>\n<td>✔︎</td>\n<td>✔</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Read commited</td>\n<td>✗</td>\n<td>✔</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Repeatable read</td>\n<td>✗</td>\n<td>✗</td>\n<td>✔</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">Serializable</td>\n<td>✗</td>\n<td>✗</td>\n<td>✗</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">for update</td>\n<td>对于搜索遇到的索引记录,锁定这行以及任何相关联的索引入口,这与<code>update</code>语句功能相似.其他事物如果在更新或者执行<code>select ... for share</code>,又或者是基于确定的事务隔离等级去读取数据,这些操作都会被堵塞.一致读取忽略读取视图中存在的记录上设置的任何锁</td>\n<td>For index records the search encounters, locks the rows and any associated index entries, the same as if you issued an <code>UPDATE</code> statement for those rows. Other transactions are blocked from updating those rows, from doing <code>SELECT ... FOR SHARE</code>, or from reading the data in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view. (Old versions of a record cannot be locked; they are reconstructed by applying <a href=\"https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log\">undo logs</a> on an in-memory copy of the record.)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">LOCK IN SHARE MODE&#x2F;FOR SHARE(8.0)</td>\n<td>在被读取的任意行上设置share mode 锁.其他会话可以读取这些行,如果要修改必须等到会话提交.如果这些行被其他事务修改但是还没提交话,你的请求等待到事务结束,并且使用最新值</td>\n<td>Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"layout":"post","title":"如何使用perf[TODO]","date":"2022-09-26T08:54:13.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n如何使用perf进行性能监测.\n\nperf是Linux系统下的一个性能分析工具.通常我们会使用perf+flamegraph进行性能分析.\n\n## 示例:\n\nunordered_map的倍增扩容机制导致抖动达毫秒级.\n\n解决方案,重新造一个unordered_map,每次扩容指定大小,削峰.\n\n","source":"_posts/2022-09-26-how-to-use-perf.md","raw":"---\nlayout: post\ntitle: 如何使用perf[TODO]\ndate: 2022-09-26 16:54:13 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url:\n---\n\n如何使用perf进行性能监测.\n\nperf是Linux系统下的一个性能分析工具.通常我们会使用perf+flamegraph进行性能分析.\n\n## 示例:\n\nunordered_map的倍增扩容机制导致抖动达毫秒级.\n\n解决方案,重新造一个unordered_map,每次扩容指定大小,削峰.\n\n","slug":"how-to-use-perf","published":1,"updated":"2023-01-03T08:15:36.424Z","comments":1,"photos":[],"link":"","_id":"clcg0w03y00087dt3676jgxqc","content":"<p>如何使用perf进行性能监测.</p>\n<p>perf是Linux系统下的一个性能分析工具.通常我们会使用perf+flamegraph进行性能分析.</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例:\"></a>示例:</h2><p>unordered_map的倍增扩容机制导致抖动达毫秒级.</p>\n<p>解决方案,重新造一个unordered_map,每次扩容指定大小,削峰.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如何使用perf进行性能监测.</p>\n<p>perf是Linux系统下的一个性能分析工具.通常我们会使用perf+flamegraph进行性能分析.</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例:\"></a>示例:</h2><p>unordered_map的倍增扩容机制导致抖动达毫秒级.</p>\n<p>解决方案,重新造一个unordered_map,每次扩容指定大小,削峰.</p>\n"},{"layout":"post","title":"booklist","date":"2022-09-27T02:15:16.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n- [ ] 编码：隐匿在计算机软硬件背后的语言\n- [ ] **深入理解计算机系统**\n- [ ] 计算机组成与设计（软硬件接口）\n- [ ] 计算机组成原理\n\n\n\n","source":"_posts/2022-09-27-booklist.md","raw":"---\nlayout: post\ntitle: booklist\ndate: 2022-09-27 10:15:16 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url:\n\n---\n\n- [ ] 编码：隐匿在计算机软硬件背后的语言\n- [ ] **深入理解计算机系统**\n- [ ] 计算机组成与设计（软硬件接口）\n- [ ] 计算机组成原理\n\n\n\n","slug":"booklist","published":1,"updated":"2023-01-03T08:15:36.424Z","comments":1,"photos":[],"link":"","_id":"clcg0w03z000b7dt37ud35fwi","content":"<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 编码：隐匿在计算机软硬件背后的语言</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>深入理解计算机系统</strong></li>\n<li><input disabled=\"\" type=\"checkbox\"> 计算机组成与设计（软硬件接口）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 计算机组成原理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 编码：隐匿在计算机软硬件背后的语言</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>深入理解计算机系统</strong></li>\n<li><input disabled=\"\" type=\"checkbox\"> 计算机组成与设计（软硬件接口）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 计算机组成原理</li>\n</ul>\n"},{"layout":"post","title":"程序的一生,从启动到消亡[TODO]","date":"2022-10-12T02:15:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n## 介绍\n\n本文基于Linux和cpp可执行文件,来讲述从cpp软件执行到软件执行结束都发生了什么.\n\n## elf格式\n\n\n\n\n\n## 函数入栈分析\n\n简单的一个可执行文件的栈变化.\n\n代码\n\n```c++\n//test.cc\nvoid test(long long i,int j){}\nint main(){\n\ttest(3,1);\n\treturn 0;\n}\n```\n\n反汇编\n\n```\nobjdumo -d test\n```\n\nmain指令\n\n整个反汇编文件分为三列，分别对应：\n\n​       指令地址:         指令机器码\t     \t\t\t\t\t\t\t\t\t\t\t\t\t\t指令机器码反汇编到的指令\n\n![image-20221031151751295](/Users/dylan/fakecore.github.io/assets/image-20221031151751295.png)\n\ntest函数\n\n![image-20221031151821182](/Users/dylan/fakecore.github.io/assets/image-20221031151821182.png)\n\n简单术语说明\n\n寄存器\n\n| Name | discription                                               |\n| ---- | --------------------------------------------------------- |\n| rbp  | Frame pointer(栈帧指针，用于标识当前栈帧的起始位置)       |\n| rsp  | Stack pointer(堆栈指针寄存器，通常会指向栈顶位置)         |\n| esi  | source index                                              |\n| edi  | destination index                                         |\n| eax  | accumulator                                               |\n| rax  | resutl register                                           |\n| rdi  | first argument reigster(six register for argument saving) |\n\n文章末尾有全的\n\n指令\n\n| name  | discription                                                  |\n| ----- | ------------------------------------------------------------ |\n| push  | 把字压入堆栈                                                 |\n| pop   | 把字弹出堆栈                                                 |\n| mov   | 传送字或字节                                                 |\n| nop   | 空操作                                                       |\n| req   | 用栈中的数据，修改IP的内容，                                 |\n| callq | call指令分为两步：<br />(1) 将当前的IP或者CS和IP压入栈中。<br />(2) 转移。<br />实现近转移。相当于 pushq %rip；jmpq addr |\n| nopl  |                                                              |\n|       |                                                              |\n|       |                                                              |\n\n**CS**是代码段寄存器，**IP**是指令指针寄存器（相当于偏移地址）\n\n函数执行步骤\n\nmain\n\n1. push %rbp rbp压入栈\n2. mov %rsp,%rbp 把rsp寄存器的值,存入rbp\n3. mov    $0x1,%esi 把1存入esi (x64是这样的,可以生成x86,那样子会压栈)\n4. mov    $0x3,%edi 把3存入edi (这里也可以看出,参数从右到左进入,主要为了不定参数的实现)\n5. callq  5d5 <_Z4testxi> 调用0x5d5\n   1. push %rbp 当前地址压入栈\n    2. mov %rsp,%rbp 把rsp寄存器的值,存入rbp\n    3. mov    %rdi,-0x8(%rbp) \n6. mov    $0x0,%eax\n7. pop    %rbp 栈数据到rbp\n8. retq\n9. nopl   (%rax)\n\n\n\n\n\n\n\n\n\n\n\n## reference\n\n1. [ret指令与call指令的深入理解](https://rj45mp.github.io/ret%E6%8C%87%E4%BB%A4%E4%B8%8Ecall%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/)\n2. https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l\n3. https://stackoverflow.com/questions/46752964/what-is-callq-instruction\n4. [程序执行汇编描述](https://segmentfault.com/a/1190000016661251)\n5. [函数栈描述](https://z.itpub.net/article/detail/50503CAA1CDDA808A925D5758BD1B0A4)\n\n## 附录![](https://pic2.zhimg.com/80/v2-bd5a0aa1625c4445ba33e506b91dba29_1440w.webp)\n\n\n\n\n\n![img](https://pic1.zhimg.com/80/v2-8f2a02c38a3b53ce857b87ed01272b80_1440w.webp)\n\n\n\n","source":"_posts/2022-10-12-a-life-of-a-process.md","raw":"---\nlayout: post\ntitle: 程序的一生,从启动到消亡[TODO]\ndate: 2022-10-12 10:15:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n\n---\n\n## 介绍\n\n本文基于Linux和cpp可执行文件,来讲述从cpp软件执行到软件执行结束都发生了什么.\n\n## elf格式\n\n\n\n\n\n## 函数入栈分析\n\n简单的一个可执行文件的栈变化.\n\n代码\n\n```c++\n//test.cc\nvoid test(long long i,int j){}\nint main(){\n\ttest(3,1);\n\treturn 0;\n}\n```\n\n反汇编\n\n```\nobjdumo -d test\n```\n\nmain指令\n\n整个反汇编文件分为三列，分别对应：\n\n​       指令地址:         指令机器码\t     \t\t\t\t\t\t\t\t\t\t\t\t\t\t指令机器码反汇编到的指令\n\n![image-20221031151751295](/Users/dylan/fakecore.github.io/assets/image-20221031151751295.png)\n\ntest函数\n\n![image-20221031151821182](/Users/dylan/fakecore.github.io/assets/image-20221031151821182.png)\n\n简单术语说明\n\n寄存器\n\n| Name | discription                                               |\n| ---- | --------------------------------------------------------- |\n| rbp  | Frame pointer(栈帧指针，用于标识当前栈帧的起始位置)       |\n| rsp  | Stack pointer(堆栈指针寄存器，通常会指向栈顶位置)         |\n| esi  | source index                                              |\n| edi  | destination index                                         |\n| eax  | accumulator                                               |\n| rax  | resutl register                                           |\n| rdi  | first argument reigster(six register for argument saving) |\n\n文章末尾有全的\n\n指令\n\n| name  | discription                                                  |\n| ----- | ------------------------------------------------------------ |\n| push  | 把字压入堆栈                                                 |\n| pop   | 把字弹出堆栈                                                 |\n| mov   | 传送字或字节                                                 |\n| nop   | 空操作                                                       |\n| req   | 用栈中的数据，修改IP的内容，                                 |\n| callq | call指令分为两步：<br />(1) 将当前的IP或者CS和IP压入栈中。<br />(2) 转移。<br />实现近转移。相当于 pushq %rip；jmpq addr |\n| nopl  |                                                              |\n|       |                                                              |\n|       |                                                              |\n\n**CS**是代码段寄存器，**IP**是指令指针寄存器（相当于偏移地址）\n\n函数执行步骤\n\nmain\n\n1. push %rbp rbp压入栈\n2. mov %rsp,%rbp 把rsp寄存器的值,存入rbp\n3. mov    $0x1,%esi 把1存入esi (x64是这样的,可以生成x86,那样子会压栈)\n4. mov    $0x3,%edi 把3存入edi (这里也可以看出,参数从右到左进入,主要为了不定参数的实现)\n5. callq  5d5 <_Z4testxi> 调用0x5d5\n   1. push %rbp 当前地址压入栈\n    2. mov %rsp,%rbp 把rsp寄存器的值,存入rbp\n    3. mov    %rdi,-0x8(%rbp) \n6. mov    $0x0,%eax\n7. pop    %rbp 栈数据到rbp\n8. retq\n9. nopl   (%rax)\n\n\n\n\n\n\n\n\n\n\n\n## reference\n\n1. [ret指令与call指令的深入理解](https://rj45mp.github.io/ret%E6%8C%87%E4%BB%A4%E4%B8%8Ecall%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/)\n2. https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l\n3. https://stackoverflow.com/questions/46752964/what-is-callq-instruction\n4. [程序执行汇编描述](https://segmentfault.com/a/1190000016661251)\n5. [函数栈描述](https://z.itpub.net/article/detail/50503CAA1CDDA808A925D5758BD1B0A4)\n\n## 附录![](https://pic2.zhimg.com/80/v2-bd5a0aa1625c4445ba33e506b91dba29_1440w.webp)\n\n\n\n\n\n![img](https://pic1.zhimg.com/80/v2-8f2a02c38a3b53ce857b87ed01272b80_1440w.webp)\n\n\n\n","slug":"a-life-of-a-process","published":1,"updated":"2023-01-03T08:15:36.424Z","comments":1,"photos":[],"link":"","_id":"clcg0w040000d7dt30r80dr03","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>本文基于Linux和cpp可执行文件,来讲述从cpp软件执行到软件执行结束都发生了什么.</p>\n<h2 id=\"elf格式\"><a href=\"#elf格式\" class=\"headerlink\" title=\"elf格式\"></a>elf格式</h2><h2 id=\"函数入栈分析\"><a href=\"#函数入栈分析\" class=\"headerlink\" title=\"函数入栈分析\"></a>函数入栈分析</h2><p>简单的一个可执行文件的栈变化.</p>\n<p>代码</p>\n<pre><code class=\"c++\">//test.cc\nvoid test(long long i,int j)&#123;&#125;\nint main()&#123;\n    test(3,1);\n    return 0;\n&#125;\n</code></pre>\n<p>反汇编</p>\n<pre><code>objdumo -d test\n</code></pre>\n<p>main指令</p>\n<p>整个反汇编文件分为三列，分别对应：</p>\n<p>​       指令地址:         指令机器码\t     \t\t\t\t\t\t\t\t\t\t\t\t\t\t指令机器码反汇编到的指令</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/image-20221031151751295.png\" alt=\"image-20221031151751295\"></p>\n<p>test函数</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/image-20221031151821182.png\" alt=\"image-20221031151821182\"></p>\n<p>简单术语说明</p>\n<p>寄存器</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>discription</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rbp</td>\n<td>Frame pointer(栈帧指针，用于标识当前栈帧的起始位置)</td>\n</tr>\n<tr>\n<td>rsp</td>\n<td>Stack pointer(堆栈指针寄存器，通常会指向栈顶位置)</td>\n</tr>\n<tr>\n<td>esi</td>\n<td>source index</td>\n</tr>\n<tr>\n<td>edi</td>\n<td>destination index</td>\n</tr>\n<tr>\n<td>eax</td>\n<td>accumulator</td>\n</tr>\n<tr>\n<td>rax</td>\n<td>resutl register</td>\n</tr>\n<tr>\n<td>rdi</td>\n<td>first argument reigster(six register for argument saving)</td>\n</tr>\n</tbody></table>\n<p>文章末尾有全的</p>\n<p>指令</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>discription</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push</td>\n<td>把字压入堆栈</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>把字弹出堆栈</td>\n</tr>\n<tr>\n<td>mov</td>\n<td>传送字或字节</td>\n</tr>\n<tr>\n<td>nop</td>\n<td>空操作</td>\n</tr>\n<tr>\n<td>req</td>\n<td>用栈中的数据，修改IP的内容，</td>\n</tr>\n<tr>\n<td>callq</td>\n<td>call指令分为两步：<br />(1) 将当前的IP或者CS和IP压入栈中。<br />(2) 转移。<br />实现近转移。相当于 pushq %rip；jmpq addr</td>\n</tr>\n<tr>\n<td>nopl</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>CS</strong>是代码段寄存器，<strong>IP</strong>是指令指针寄存器（相当于偏移地址）</p>\n<p>函数执行步骤</p>\n<p>main</p>\n<ol>\n<li>push %rbp rbp压入栈</li>\n<li>mov %rsp,%rbp 把rsp寄存器的值,存入rbp</li>\n<li>mov    $0x1,%esi 把1存入esi (x64是这样的,可以生成x86,那样子会压栈)</li>\n<li>mov    $0x3,%edi 把3存入edi (这里也可以看出,参数从右到左进入,主要为了不定参数的实现)</li>\n<li>callq  5d5 &lt;_Z4testxi&gt; 调用0x5d5<ol>\n<li>push %rbp 当前地址压入栈</li>\n<li>mov %rsp,%rbp 把rsp寄存器的值,存入rbp</li>\n<li>mov    %rdi,-0x8(%rbp)</li>\n</ol>\n</li>\n<li>mov    $0x0,%eax</li>\n<li>pop    %rbp 栈数据到rbp</li>\n<li>retq</li>\n<li>nopl   (%rax)</li>\n</ol>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ol>\n<li><a href=\"https://rj45mp.github.io/ret%E6%8C%87%E4%BB%A4%E4%B8%8Ecall%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/\">ret指令与call指令的深入理解</a></li>\n<li><a href=\"https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l\">https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l</a></li>\n<li><a href=\"https://stackoverflow.com/questions/46752964/what-is-callq-instruction\">https://stackoverflow.com/questions/46752964/what-is-callq-instruction</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016661251\">程序执行汇编描述</a></li>\n<li><a href=\"https://z.itpub.net/article/detail/50503CAA1CDDA808A925D5758BD1B0A4\">函数栈描述</a></li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录<img src=\"https://pic2.zhimg.com/80/v2-bd5a0aa1625c4445ba33e506b91dba29_1440w.webp\"></h2><p><img src=\"https://pic1.zhimg.com/80/v2-8f2a02c38a3b53ce857b87ed01272b80_1440w.webp\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>本文基于Linux和cpp可执行文件,来讲述从cpp软件执行到软件执行结束都发生了什么.</p>\n<h2 id=\"elf格式\"><a href=\"#elf格式\" class=\"headerlink\" title=\"elf格式\"></a>elf格式</h2><h2 id=\"函数入栈分析\"><a href=\"#函数入栈分析\" class=\"headerlink\" title=\"函数入栈分析\"></a>函数入栈分析</h2><p>简单的一个可执行文件的栈变化.</p>\n<p>代码</p>\n<pre><code class=\"c++\">//test.cc\nvoid test(long long i,int j)&#123;&#125;\nint main()&#123;\n    test(3,1);\n    return 0;\n&#125;\n</code></pre>\n<p>反汇编</p>\n<pre><code>objdumo -d test\n</code></pre>\n<p>main指令</p>\n<p>整个反汇编文件分为三列，分别对应：</p>\n<p>​       指令地址:         指令机器码\t     \t\t\t\t\t\t\t\t\t\t\t\t\t\t指令机器码反汇编到的指令</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/image-20221031151751295.png\" alt=\"image-20221031151751295\"></p>\n<p>test函数</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/image-20221031151821182.png\" alt=\"image-20221031151821182\"></p>\n<p>简单术语说明</p>\n<p>寄存器</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>discription</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rbp</td>\n<td>Frame pointer(栈帧指针，用于标识当前栈帧的起始位置)</td>\n</tr>\n<tr>\n<td>rsp</td>\n<td>Stack pointer(堆栈指针寄存器，通常会指向栈顶位置)</td>\n</tr>\n<tr>\n<td>esi</td>\n<td>source index</td>\n</tr>\n<tr>\n<td>edi</td>\n<td>destination index</td>\n</tr>\n<tr>\n<td>eax</td>\n<td>accumulator</td>\n</tr>\n<tr>\n<td>rax</td>\n<td>resutl register</td>\n</tr>\n<tr>\n<td>rdi</td>\n<td>first argument reigster(six register for argument saving)</td>\n</tr>\n</tbody></table>\n<p>文章末尾有全的</p>\n<p>指令</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>discription</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push</td>\n<td>把字压入堆栈</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>把字弹出堆栈</td>\n</tr>\n<tr>\n<td>mov</td>\n<td>传送字或字节</td>\n</tr>\n<tr>\n<td>nop</td>\n<td>空操作</td>\n</tr>\n<tr>\n<td>req</td>\n<td>用栈中的数据，修改IP的内容，</td>\n</tr>\n<tr>\n<td>callq</td>\n<td>call指令分为两步：<br />(1) 将当前的IP或者CS和IP压入栈中。<br />(2) 转移。<br />实现近转移。相当于 pushq %rip；jmpq addr</td>\n</tr>\n<tr>\n<td>nopl</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>CS</strong>是代码段寄存器，<strong>IP</strong>是指令指针寄存器（相当于偏移地址）</p>\n<p>函数执行步骤</p>\n<p>main</p>\n<ol>\n<li>push %rbp rbp压入栈</li>\n<li>mov %rsp,%rbp 把rsp寄存器的值,存入rbp</li>\n<li>mov    $0x1,%esi 把1存入esi (x64是这样的,可以生成x86,那样子会压栈)</li>\n<li>mov    $0x3,%edi 把3存入edi (这里也可以看出,参数从右到左进入,主要为了不定参数的实现)</li>\n<li>callq  5d5 &lt;_Z4testxi&gt; 调用0x5d5<ol>\n<li>push %rbp 当前地址压入栈</li>\n<li>mov %rsp,%rbp 把rsp寄存器的值,存入rbp</li>\n<li>mov    %rdi,-0x8(%rbp)</li>\n</ol>\n</li>\n<li>mov    $0x0,%eax</li>\n<li>pop    %rbp 栈数据到rbp</li>\n<li>retq</li>\n<li>nopl   (%rax)</li>\n</ol>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ol>\n<li><a href=\"https://rj45mp.github.io/ret%E6%8C%87%E4%BB%A4%E4%B8%8Ecall%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/\">ret指令与call指令的深入理解</a></li>\n<li><a href=\"https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l\">https://stackoverflow.com/questions/14296088/what-is-this-assembly-function-prologue-epilogue-code-doing-with-rbp-rsp-l</a></li>\n<li><a href=\"https://stackoverflow.com/questions/46752964/what-is-callq-instruction\">https://stackoverflow.com/questions/46752964/what-is-callq-instruction</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016661251\">程序执行汇编描述</a></li>\n<li><a href=\"https://z.itpub.net/article/detail/50503CAA1CDDA808A925D5758BD1B0A4\">函数栈描述</a></li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录<img src=\"https://pic2.zhimg.com/80/v2-bd5a0aa1625c4445ba33e506b91dba29_1440w.webp\"></h2><p><img src=\"https://pic1.zhimg.com/80/v2-8f2a02c38a3b53ce857b87ed01272b80_1440w.webp\" alt=\"img\"></p>\n"},{"layout":"post","title":"cpp生产问题汇总","date":"2022-10-20T02:07:03.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n## std::bad_alloc\n\n程序报std::bad_alloc,通过gdb简单排查,判断异常函数出在通过std::bind注册的定时程序.\n\n结果:函数定义返回json,最后忘记添加返回语句,(gcc和msvc相关文档说道,对于这种情况,作为未定义动作).并且在CmakeLists.txt并没有添加检查返回类型的编译选项\n\n处理结果:把函数返回类型改成void,并且给编译选项加上-Wreturn-type(发现项目已经加上,只是没有对于这些编译过程中出现的warning进行处理)\n\n补充知识:对于有定义返回类型的函数,如果没有显示写出return,编译器可能会从eax(EAX 是\"累加器\"(accumulator), 它是很多加法乘法指令的缺省寄存器)或者al寄存器拿值,返回.\n\n","source":"_posts/2022-10-20-cpp-product-problems.md","raw":"---\nlayout: post\ntitle: cpp生产问题汇总\ndate: 2022-10-20 10:07:03 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\n\n\n## std::bad_alloc\n\n程序报std::bad_alloc,通过gdb简单排查,判断异常函数出在通过std::bind注册的定时程序.\n\n结果:函数定义返回json,最后忘记添加返回语句,(gcc和msvc相关文档说道,对于这种情况,作为未定义动作).并且在CmakeLists.txt并没有添加检查返回类型的编译选项\n\n处理结果:把函数返回类型改成void,并且给编译选项加上-Wreturn-type(发现项目已经加上,只是没有对于这些编译过程中出现的warning进行处理)\n\n补充知识:对于有定义返回类型的函数,如果没有显示写出return,编译器可能会从eax(EAX 是\"累加器\"(accumulator), 它是很多加法乘法指令的缺省寄存器)或者al寄存器拿值,返回.\n\n","slug":"cpp-product-problems","published":1,"updated":"2023-01-03T08:15:36.425Z","comments":1,"photos":[],"link":"","_id":"clcg0w040000g7dt3hvj598ft","content":"<h2 id=\"std-bad-alloc\"><a href=\"#std-bad-alloc\" class=\"headerlink\" title=\"std::bad_alloc\"></a>std::bad_alloc</h2><p>程序报std::bad_alloc,通过gdb简单排查,判断异常函数出在通过std::bind注册的定时程序.</p>\n<p>结果:函数定义返回json,最后忘记添加返回语句,(gcc和msvc相关文档说道,对于这种情况,作为未定义动作).并且在CmakeLists.txt并没有添加检查返回类型的编译选项</p>\n<p>处理结果:把函数返回类型改成void,并且给编译选项加上-Wreturn-type(发现项目已经加上,只是没有对于这些编译过程中出现的warning进行处理)</p>\n<p>补充知识:对于有定义返回类型的函数,如果没有显示写出return,编译器可能会从eax(EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器)或者al寄存器拿值,返回.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"std-bad-alloc\"><a href=\"#std-bad-alloc\" class=\"headerlink\" title=\"std::bad_alloc\"></a>std::bad_alloc</h2><p>程序报std::bad_alloc,通过gdb简单排查,判断异常函数出在通过std::bind注册的定时程序.</p>\n<p>结果:函数定义返回json,最后忘记添加返回语句,(gcc和msvc相关文档说道,对于这种情况,作为未定义动作).并且在CmakeLists.txt并没有添加检查返回类型的编译选项</p>\n<p>处理结果:把函数返回类型改成void,并且给编译选项加上-Wreturn-type(发现项目已经加上,只是没有对于这些编译过程中出现的warning进行处理)</p>\n<p>补充知识:对于有定义返回类型的函数,如果没有显示写出return,编译器可能会从eax(EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器)或者al寄存器拿值,返回.</p>\n"},{"layout":"post","title":"cpp 对象模型(虚表解析)","date":"2022-10-17T09:32:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n环境:Linux arm64 gcc\n\n虚表是c++实现多态的一个重要内容.\n\n让我们来看看不同的类生成的对象如何.\n\n```c++\n\nclass BaseA{\n};\n\nclass BaseB{\n\tvoid hi(){}\n\tint word;\n};\n\nclass BaseC{\n  virtual void ff(){}\n  virtual void k(){}\n};\n\nclass BaseD{\n  virtual void ff(){}\n};\n\nclass BaseE{\n  virtual void ff(){}\n  int word;\n};\n\nclass DerivedC: public BaseC{\n  void ff() override{}\n};\n\nclass DerivedD: public BaseC,public BaseD{\n  void ff() override{}\n};\n\nint main(){\n\n    BaseA ba;\n    BaseB bb;\n    BaseC bc;\n    BaseD bd;\n    BaseE be;\n    DerivedC dc;\n    DerivedD dd;\n\n    return 0;\n}\n\n```\n\n先说结论.我们来看看每个类实例的内存布局.\n\n![cpp_class_model](/Users/dylan/fakecore.github.io/assets/cpp_class_model.png)\n\n今天我们用gdb来看看如何进行查看\n\n1.设置打印友好\n\n2.普通继承.\n\n- 先根据基类虚函数生成一个虚表\n- 根据子类虚函数,如果有重名的,参数相同.覆盖虚表上父类对应函数位置,如果同名,不同参数,则在后面添加. 如果是一个新函数,也一样在后面添加.\n\n```c++\n(gdb) set print pretty on\n(gdb) p dc\n$67 = {\n  <BaseC> = {\n    _vptr.BaseC = 0xaaaaaaab1cd8 <vtable for DerivedC+16>\n  }, <No data fields>}\n(gdb) p *((void**)0xaaaaaaab1cd8-1)\n$68 = (void *) 0xaaaaaaab1d78 <typeinfo for DerivedC>\n(gdb) p *((void**)0xaaaaaaab1cd8)\n$69 = (void *) 0xaaaaaaaa1018 <DerivedC::ff()>\n(gdb) p *((void**)0xaaaaaaab1cd8+1)\n$70 = (void *) 0xaaaaaaaa0fdc <BaseC::k()>\n(gdb) p *((void**)0xaaaaaaab1cd8+2)\n$71 = (void *) 0xaaaaaaaa102c <DerivedC::nd()>\n(gdb) p *((void**)0xaaaaaaab1cd8+Quit\n(gdb) p *((void**)0xaaaaaaab1cd8+3)\n$72 = (void *) 0x0\n(gdb) p *((void**)0xaaaaaaab1cd8+3Quit\n// 打印dd相关\n(gdb) p dd\n$73 = {\n  <BaseC> = {\n    _vptr.BaseC = 0xaaaaaaab1ca0 <vtable for DerivedD+16>\n  }, \n  <BaseD> = {\n    _vptr.BaseD = 0xaaaaaaab1cc0 <vtable for DerivedD+48>\n  }, <No data fields>}\n(gdb) p *((void**)0xaaaaaaab1ca0-1)\n$74 = (void *) 0xaaaaaaab1d40 <typeinfo for DerivedD>\n(gdb) p *((void**)0xaaaaaaab1ca0)\n$75 = (void *) 0xaaaaaaaa1040 <DerivedD::ff()>\n(gdb) p *((void**)0xaaaaaaab1ca0+1)\n$76 = (void *) 0xaaaaaaaa0fdc <BaseC::k()>\n(gdb) p *((void**)0xaaaaaaab1cc0-1)\n$81 = (void *) 0xaaaaaaab1d40 <typeinfo for DerivedD>\n(gdb) p *((void**)0xaaaaaaab1cc0)\n$82 = (void *) 0xaaaaaaaa1054 <non-virtual thunk to DerivedD::ff()>\n(gdb) p *((void**)0xaaaaaaab1cc0+1)\n$83 = (void *) 0x0\n```\n\n虚函数表在哪里\n\n**C++虚函数表保存在.rdata只读数据段**。编译时期由[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)确定虚函数表。虚函数表属于类，类的所有对象共享这个类的虚函数表。\n\n","source":"_posts/2022-10-17-cpp-virtual-table.md","raw":"---\nlayout: post\ntitle: cpp 对象模型(虚表解析)\ndate: 2022-10-17 17:32:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n\n---\n\n\n\n环境:Linux arm64 gcc\n\n虚表是c++实现多态的一个重要内容.\n\n让我们来看看不同的类生成的对象如何.\n\n```c++\n\nclass BaseA{\n};\n\nclass BaseB{\n\tvoid hi(){}\n\tint word;\n};\n\nclass BaseC{\n  virtual void ff(){}\n  virtual void k(){}\n};\n\nclass BaseD{\n  virtual void ff(){}\n};\n\nclass BaseE{\n  virtual void ff(){}\n  int word;\n};\n\nclass DerivedC: public BaseC{\n  void ff() override{}\n};\n\nclass DerivedD: public BaseC,public BaseD{\n  void ff() override{}\n};\n\nint main(){\n\n    BaseA ba;\n    BaseB bb;\n    BaseC bc;\n    BaseD bd;\n    BaseE be;\n    DerivedC dc;\n    DerivedD dd;\n\n    return 0;\n}\n\n```\n\n先说结论.我们来看看每个类实例的内存布局.\n\n![cpp_class_model](/Users/dylan/fakecore.github.io/assets/cpp_class_model.png)\n\n今天我们用gdb来看看如何进行查看\n\n1.设置打印友好\n\n2.普通继承.\n\n- 先根据基类虚函数生成一个虚表\n- 根据子类虚函数,如果有重名的,参数相同.覆盖虚表上父类对应函数位置,如果同名,不同参数,则在后面添加. 如果是一个新函数,也一样在后面添加.\n\n```c++\n(gdb) set print pretty on\n(gdb) p dc\n$67 = {\n  <BaseC> = {\n    _vptr.BaseC = 0xaaaaaaab1cd8 <vtable for DerivedC+16>\n  }, <No data fields>}\n(gdb) p *((void**)0xaaaaaaab1cd8-1)\n$68 = (void *) 0xaaaaaaab1d78 <typeinfo for DerivedC>\n(gdb) p *((void**)0xaaaaaaab1cd8)\n$69 = (void *) 0xaaaaaaaa1018 <DerivedC::ff()>\n(gdb) p *((void**)0xaaaaaaab1cd8+1)\n$70 = (void *) 0xaaaaaaaa0fdc <BaseC::k()>\n(gdb) p *((void**)0xaaaaaaab1cd8+2)\n$71 = (void *) 0xaaaaaaaa102c <DerivedC::nd()>\n(gdb) p *((void**)0xaaaaaaab1cd8+Quit\n(gdb) p *((void**)0xaaaaaaab1cd8+3)\n$72 = (void *) 0x0\n(gdb) p *((void**)0xaaaaaaab1cd8+3Quit\n// 打印dd相关\n(gdb) p dd\n$73 = {\n  <BaseC> = {\n    _vptr.BaseC = 0xaaaaaaab1ca0 <vtable for DerivedD+16>\n  }, \n  <BaseD> = {\n    _vptr.BaseD = 0xaaaaaaab1cc0 <vtable for DerivedD+48>\n  }, <No data fields>}\n(gdb) p *((void**)0xaaaaaaab1ca0-1)\n$74 = (void *) 0xaaaaaaab1d40 <typeinfo for DerivedD>\n(gdb) p *((void**)0xaaaaaaab1ca0)\n$75 = (void *) 0xaaaaaaaa1040 <DerivedD::ff()>\n(gdb) p *((void**)0xaaaaaaab1ca0+1)\n$76 = (void *) 0xaaaaaaaa0fdc <BaseC::k()>\n(gdb) p *((void**)0xaaaaaaab1cc0-1)\n$81 = (void *) 0xaaaaaaab1d40 <typeinfo for DerivedD>\n(gdb) p *((void**)0xaaaaaaab1cc0)\n$82 = (void *) 0xaaaaaaaa1054 <non-virtual thunk to DerivedD::ff()>\n(gdb) p *((void**)0xaaaaaaab1cc0+1)\n$83 = (void *) 0x0\n```\n\n虚函数表在哪里\n\n**C++虚函数表保存在.rdata只读数据段**。编译时期由[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)确定虚函数表。虚函数表属于类，类的所有对象共享这个类的虚函数表。\n\n","slug":"cpp-virtual-table","published":1,"updated":"2023-01-03T08:15:36.425Z","comments":1,"photos":[],"link":"","_id":"clcg0w041000i7dt3g25f3hx4","content":"<p>环境:Linux arm64 gcc</p>\n<p>虚表是c++实现多态的一个重要内容.</p>\n<p>让我们来看看不同的类生成的对象如何.</p>\n<pre><code class=\"c++\">\nclass BaseA&#123;\n&#125;;\n\nclass BaseB&#123;\n    void hi()&#123;&#125;\n    int word;\n&#125;;\n\nclass BaseC&#123;\n  virtual void ff()&#123;&#125;\n  virtual void k()&#123;&#125;\n&#125;;\n\nclass BaseD&#123;\n  virtual void ff()&#123;&#125;\n&#125;;\n\nclass BaseE&#123;\n  virtual void ff()&#123;&#125;\n  int word;\n&#125;;\n\nclass DerivedC: public BaseC&#123;\n  void ff() override&#123;&#125;\n&#125;;\n\nclass DerivedD: public BaseC,public BaseD&#123;\n  void ff() override&#123;&#125;\n&#125;;\n\nint main()&#123;\n\n    BaseA ba;\n    BaseB bb;\n    BaseC bc;\n    BaseD bd;\n    BaseE be;\n    DerivedC dc;\n    DerivedD dd;\n\n    return 0;\n&#125;\n</code></pre>\n<p>先说结论.我们来看看每个类实例的内存布局.</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/cpp_class_model.png\" alt=\"cpp_class_model\"></p>\n<p>今天我们用gdb来看看如何进行查看</p>\n<p>1.设置打印友好</p>\n<p>2.普通继承.</p>\n<ul>\n<li>先根据基类虚函数生成一个虚表</li>\n<li>根据子类虚函数,如果有重名的,参数相同.覆盖虚表上父类对应函数位置,如果同名,不同参数,则在后面添加. 如果是一个新函数,也一样在后面添加.</li>\n</ul>\n<pre><code class=\"c++\">(gdb) set print pretty on\n(gdb) p dc\n$67 = &#123;\n  &lt;BaseC&gt; = &#123;\n    _vptr.BaseC = 0xaaaaaaab1cd8 &lt;vtable for DerivedC+16&gt;\n  &#125;, &lt;No data fields&gt;&#125;\n(gdb) p *((void**)0xaaaaaaab1cd8-1)\n$68 = (void *) 0xaaaaaaab1d78 &lt;typeinfo for DerivedC&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8)\n$69 = (void *) 0xaaaaaaaa1018 &lt;DerivedC::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+1)\n$70 = (void *) 0xaaaaaaaa0fdc &lt;BaseC::k()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+2)\n$71 = (void *) 0xaaaaaaaa102c &lt;DerivedC::nd()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+Quit\n(gdb) p *((void**)0xaaaaaaab1cd8+3)\n$72 = (void *) 0x0\n(gdb) p *((void**)0xaaaaaaab1cd8+3Quit\n// 打印dd相关\n(gdb) p dd\n$73 = &#123;\n  &lt;BaseC&gt; = &#123;\n    _vptr.BaseC = 0xaaaaaaab1ca0 &lt;vtable for DerivedD+16&gt;\n  &#125;, \n  &lt;BaseD&gt; = &#123;\n    _vptr.BaseD = 0xaaaaaaab1cc0 &lt;vtable for DerivedD+48&gt;\n  &#125;, &lt;No data fields&gt;&#125;\n(gdb) p *((void**)0xaaaaaaab1ca0-1)\n$74 = (void *) 0xaaaaaaab1d40 &lt;typeinfo for DerivedD&gt;\n(gdb) p *((void**)0xaaaaaaab1ca0)\n$75 = (void *) 0xaaaaaaaa1040 &lt;DerivedD::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1ca0+1)\n$76 = (void *) 0xaaaaaaaa0fdc &lt;BaseC::k()&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0-1)\n$81 = (void *) 0xaaaaaaab1d40 &lt;typeinfo for DerivedD&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0)\n$82 = (void *) 0xaaaaaaaa1054 &lt;non-virtual thunk to DerivedD::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0+1)\n$83 = (void *) 0x0\n</code></pre>\n<p>虚函数表在哪里</p>\n<p><strong>C++虚函数表保存在.rdata只读数据段</strong>。编译时期由<a href=\"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020\">编译器</a>确定虚函数表。虚函数表属于类，类的所有对象共享这个类的虚函数表。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>环境:Linux arm64 gcc</p>\n<p>虚表是c++实现多态的一个重要内容.</p>\n<p>让我们来看看不同的类生成的对象如何.</p>\n<pre><code class=\"c++\">\nclass BaseA&#123;\n&#125;;\n\nclass BaseB&#123;\n    void hi()&#123;&#125;\n    int word;\n&#125;;\n\nclass BaseC&#123;\n  virtual void ff()&#123;&#125;\n  virtual void k()&#123;&#125;\n&#125;;\n\nclass BaseD&#123;\n  virtual void ff()&#123;&#125;\n&#125;;\n\nclass BaseE&#123;\n  virtual void ff()&#123;&#125;\n  int word;\n&#125;;\n\nclass DerivedC: public BaseC&#123;\n  void ff() override&#123;&#125;\n&#125;;\n\nclass DerivedD: public BaseC,public BaseD&#123;\n  void ff() override&#123;&#125;\n&#125;;\n\nint main()&#123;\n\n    BaseA ba;\n    BaseB bb;\n    BaseC bc;\n    BaseD bd;\n    BaseE be;\n    DerivedC dc;\n    DerivedD dd;\n\n    return 0;\n&#125;\n</code></pre>\n<p>先说结论.我们来看看每个类实例的内存布局.</p>\n<p><img src=\"/Users/dylan/fakecore.github.io/assets/cpp_class_model.png\" alt=\"cpp_class_model\"></p>\n<p>今天我们用gdb来看看如何进行查看</p>\n<p>1.设置打印友好</p>\n<p>2.普通继承.</p>\n<ul>\n<li>先根据基类虚函数生成一个虚表</li>\n<li>根据子类虚函数,如果有重名的,参数相同.覆盖虚表上父类对应函数位置,如果同名,不同参数,则在后面添加. 如果是一个新函数,也一样在后面添加.</li>\n</ul>\n<pre><code class=\"c++\">(gdb) set print pretty on\n(gdb) p dc\n$67 = &#123;\n  &lt;BaseC&gt; = &#123;\n    _vptr.BaseC = 0xaaaaaaab1cd8 &lt;vtable for DerivedC+16&gt;\n  &#125;, &lt;No data fields&gt;&#125;\n(gdb) p *((void**)0xaaaaaaab1cd8-1)\n$68 = (void *) 0xaaaaaaab1d78 &lt;typeinfo for DerivedC&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8)\n$69 = (void *) 0xaaaaaaaa1018 &lt;DerivedC::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+1)\n$70 = (void *) 0xaaaaaaaa0fdc &lt;BaseC::k()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+2)\n$71 = (void *) 0xaaaaaaaa102c &lt;DerivedC::nd()&gt;\n(gdb) p *((void**)0xaaaaaaab1cd8+Quit\n(gdb) p *((void**)0xaaaaaaab1cd8+3)\n$72 = (void *) 0x0\n(gdb) p *((void**)0xaaaaaaab1cd8+3Quit\n// 打印dd相关\n(gdb) p dd\n$73 = &#123;\n  &lt;BaseC&gt; = &#123;\n    _vptr.BaseC = 0xaaaaaaab1ca0 &lt;vtable for DerivedD+16&gt;\n  &#125;, \n  &lt;BaseD&gt; = &#123;\n    _vptr.BaseD = 0xaaaaaaab1cc0 &lt;vtable for DerivedD+48&gt;\n  &#125;, &lt;No data fields&gt;&#125;\n(gdb) p *((void**)0xaaaaaaab1ca0-1)\n$74 = (void *) 0xaaaaaaab1d40 &lt;typeinfo for DerivedD&gt;\n(gdb) p *((void**)0xaaaaaaab1ca0)\n$75 = (void *) 0xaaaaaaaa1040 &lt;DerivedD::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1ca0+1)\n$76 = (void *) 0xaaaaaaaa0fdc &lt;BaseC::k()&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0-1)\n$81 = (void *) 0xaaaaaaab1d40 &lt;typeinfo for DerivedD&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0)\n$82 = (void *) 0xaaaaaaaa1054 &lt;non-virtual thunk to DerivedD::ff()&gt;\n(gdb) p *((void**)0xaaaaaaab1cc0+1)\n$83 = (void *) 0x0\n</code></pre>\n<p>虚函数表在哪里</p>\n<p><strong>C++虚函数表保存在.rdata只读数据段</strong>。编译时期由<a href=\"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020\">编译器</a>确定虚函数表。虚函数表属于类，类的所有对象共享这个类的虚函数表。</p>\n"},{"layout":"post","title":"c/c++ ABI Problem","date":"2022-10-31T02:45:10.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n事实上c/c++均没有稳定的abi.\n\ngcc5.1之后会有abi问题.因为引入了c++11,为了保证向前兼容,额外添加了namespace去保存c++11的特性.\n\n所以在这个前后编译的版本会存在abi问题.另外可以通过指令,使用老式abi进行编译.\n\n```cmake\n-D_GLIBCXX_USE_CXX11_ABI=0\n```\n\n\n\n## 为什么C没有ABI,在Linux上却依然可以兼容运行?\n\n因为[LSB(linux Standard Base)](https://refspecs.linuxfoundation.org/),它定义了一套ABI兼容性布局,目标就是使程序能跨机器,跨版本,跨发行版本运行.\n\n## 什么情况会破坏ABI兼容\n\n\t1.\t修改导出函数参数\n\t1.\t改变了虚函数的offset或者成员的顺序\n\t1.\t添加新的虚函数\n\t1.\t不导出或者移除一个导出类\n\t1.\t改变类的继承\n\t1.\t改变虚函数声明时的顺序（偏移量改变，导致调用失败）\n\t1.\t添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化）\n\t1.\t改变非静态成员变量的声明顺序\n\n## 不会破坏ABI兼容\n\n1. 添加非虚函数（包括构造函数）\n2. 添加新的类\n3. 添加新的静态成员变量\n4. 修改成员变量名称（偏移量未改变）\n\n​\t\n\n\n\n\n\n\n\n## Reference:\n\n1. https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji\n\n2. https://en.wikipedia.org/wiki/Application_binary_interface\n\n3. http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx\n\n4. https://www.cnblogs.com/my_life/articles/12154978.html\n\n5. https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9\n","source":"_posts/2022-10-31-c_cpp_abi_problem.md","raw":"---\nlayout: post\ntitle: c/c++ ABI Problem\ndate: 2022-10-31 10:45:10 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\n\n\n事实上c/c++均没有稳定的abi.\n\ngcc5.1之后会有abi问题.因为引入了c++11,为了保证向前兼容,额外添加了namespace去保存c++11的特性.\n\n所以在这个前后编译的版本会存在abi问题.另外可以通过指令,使用老式abi进行编译.\n\n```cmake\n-D_GLIBCXX_USE_CXX11_ABI=0\n```\n\n\n\n## 为什么C没有ABI,在Linux上却依然可以兼容运行?\n\n因为[LSB(linux Standard Base)](https://refspecs.linuxfoundation.org/),它定义了一套ABI兼容性布局,目标就是使程序能跨机器,跨版本,跨发行版本运行.\n\n## 什么情况会破坏ABI兼容\n\n\t1.\t修改导出函数参数\n\t1.\t改变了虚函数的offset或者成员的顺序\n\t1.\t添加新的虚函数\n\t1.\t不导出或者移除一个导出类\n\t1.\t改变类的继承\n\t1.\t改变虚函数声明时的顺序（偏移量改变，导致调用失败）\n\t1.\t添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化）\n\t1.\t改变非静态成员变量的声明顺序\n\n## 不会破坏ABI兼容\n\n1. 添加非虚函数（包括构造函数）\n2. 添加新的类\n3. 添加新的静态成员变量\n4. 修改成员变量名称（偏移量未改变）\n\n​\t\n\n\n\n\n\n\n\n## Reference:\n\n1. https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji\n\n2. https://en.wikipedia.org/wiki/Application_binary_interface\n\n3. http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx\n\n4. https://www.cnblogs.com/my_life/articles/12154978.html\n\n5. https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9\n","slug":"c_cpp_abi_problem","published":1,"updated":"2023-01-03T08:15:36.426Z","comments":1,"photos":[],"link":"","_id":"clcg0w041000k7dt38van50ng","content":"<p>事实上c&#x2F;c++均没有稳定的abi.</p>\n<p>gcc5.1之后会有abi问题.因为引入了c++11,为了保证向前兼容,额外添加了namespace去保存c++11的特性.</p>\n<p>所以在这个前后编译的版本会存在abi问题.另外可以通过指令,使用老式abi进行编译.</p>\n<pre><code class=\"cmake\">-D_GLIBCXX_USE_CXX11_ABI=0\n</code></pre>\n<h2 id=\"为什么C没有ABI-在Linux上却依然可以兼容运行\"><a href=\"#为什么C没有ABI-在Linux上却依然可以兼容运行\" class=\"headerlink\" title=\"为什么C没有ABI,在Linux上却依然可以兼容运行?\"></a>为什么C没有ABI,在Linux上却依然可以兼容运行?</h2><p>因为<a href=\"https://refspecs.linuxfoundation.org/\">LSB(linux Standard Base)</a>,它定义了一套ABI兼容性布局,目标就是使程序能跨机器,跨版本,跨发行版本运行.</p>\n<h2 id=\"什么情况会破坏ABI兼容\"><a href=\"#什么情况会破坏ABI兼容\" class=\"headerlink\" title=\"什么情况会破坏ABI兼容\"></a>什么情况会破坏ABI兼容</h2><pre><code>1.\t修改导出函数参数\n1.\t改变了虚函数的offset或者成员的顺序\n1.\t添加新的虚函数\n1.\t不导出或者移除一个导出类\n1.\t改变类的继承\n1.\t改变虚函数声明时的顺序（偏移量改变，导致调用失败）\n1.\t添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化）\n1.\t改变非静态成员变量的声明顺序\n</code></pre>\n<h2 id=\"不会破坏ABI兼容\"><a href=\"#不会破坏ABI兼容\" class=\"headerlink\" title=\"不会破坏ABI兼容\"></a>不会破坏ABI兼容</h2><ol>\n<li>添加非虚函数（包括构造函数）</li>\n<li>添加新的类</li>\n<li>添加新的静态成员变量</li>\n<li>修改成员变量名称（偏移量未改变）</li>\n</ol>\n<p>​\t</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h2><ol>\n<li><p><a href=\"https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji\">https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\">https://en.wikipedia.org/wiki/Application_binary_interface</a></p>\n</li>\n<li><p><a href=\"http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx\">http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/my_life/articles/12154978.html\">https://www.cnblogs.com/my_life/articles/12154978.html</a></p>\n</li>\n<li><p><a href=\"https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9\">https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>事实上c&#x2F;c++均没有稳定的abi.</p>\n<p>gcc5.1之后会有abi问题.因为引入了c++11,为了保证向前兼容,额外添加了namespace去保存c++11的特性.</p>\n<p>所以在这个前后编译的版本会存在abi问题.另外可以通过指令,使用老式abi进行编译.</p>\n<pre><code class=\"cmake\">-D_GLIBCXX_USE_CXX11_ABI=0\n</code></pre>\n<h2 id=\"为什么C没有ABI-在Linux上却依然可以兼容运行\"><a href=\"#为什么C没有ABI-在Linux上却依然可以兼容运行\" class=\"headerlink\" title=\"为什么C没有ABI,在Linux上却依然可以兼容运行?\"></a>为什么C没有ABI,在Linux上却依然可以兼容运行?</h2><p>因为<a href=\"https://refspecs.linuxfoundation.org/\">LSB(linux Standard Base)</a>,它定义了一套ABI兼容性布局,目标就是使程序能跨机器,跨版本,跨发行版本运行.</p>\n<h2 id=\"什么情况会破坏ABI兼容\"><a href=\"#什么情况会破坏ABI兼容\" class=\"headerlink\" title=\"什么情况会破坏ABI兼容\"></a>什么情况会破坏ABI兼容</h2><pre><code>1.\t修改导出函数参数\n1.\t改变了虚函数的offset或者成员的顺序\n1.\t添加新的虚函数\n1.\t不导出或者移除一个导出类\n1.\t改变类的继承\n1.\t改变虚函数声明时的顺序（偏移量改变，导致调用失败）\n1.\t添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化）\n1.\t改变非静态成员变量的声明顺序\n</code></pre>\n<h2 id=\"不会破坏ABI兼容\"><a href=\"#不会破坏ABI兼容\" class=\"headerlink\" title=\"不会破坏ABI兼容\"></a>不会破坏ABI兼容</h2><ol>\n<li>添加非虚函数（包括构造函数）</li>\n<li>添加新的类</li>\n<li>添加新的静态成员变量</li>\n<li>修改成员变量名称（偏移量未改变）</li>\n</ol>\n<p>​\t</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h2><ol>\n<li><p><a href=\"https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji\">https://www.infoq.cn/article/pqi0lyv7hhmsghkpzkji</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\">https://en.wikipedia.org/wiki/Application_binary_interface</a></p>\n</li>\n<li><p><a href=\"http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx\">http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/my_life/articles/12154978.html\">https://www.cnblogs.com/my_life/articles/12154978.html</a></p>\n</li>\n<li><p><a href=\"https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9\">https://nextstart.online/2021/12/14/ABI/#4-%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0abi%E5%85%BC%E5%AE%B9</a></p>\n</li>\n</ol>\n"},{"layout":"post","title":"memcpy!为什么那么快!","date":"2022-10-27T02:56:37.000Z","last_modified_at":"2022-12-17 02:32:09 +0800","author":"fakecore","author_url":null,"_content":"\n相信学过c/c++的对这个函数都不会陌生.拷贝一段内存时,我们通常会使用memcpy或者循环拷贝.\n\n只是大家想过没有,为什么memcpy那么快,它到底藏了什么魔法?\n\nmemcpy会使用SIMD指令,做多字拷贝.\n\n正常我们写循环拷贝都是按照基础类型本身来进行,单次拷贝可能是在1-4byte之间.但是memcpy按照4byte进行拷贝.所以它的拷贝速度会比较快.\n\n\n\n## SIMD\n\n单指令流多数据流是一种采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元，例如Intel的MMX或SSE，以及AMD的3D Now!指令集。\n\n## 如何比memcpy还快\n\n多线程拷贝\n\n## Reference\n\n1.https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\n\n","source":"_posts/2022-10-27-why-memcpy-is-faster-than-others.md","raw":"---\nlayout: post\ntitle: memcpy!为什么那么快!\ndate: 2022-10-27 10:56:37 +0800\nlast_modified_at: 2022-12-17 02:32:09 +0800\ntags: []\nauthor: fakecore\nauthor_url:\n---\n\n相信学过c/c++的对这个函数都不会陌生.拷贝一段内存时,我们通常会使用memcpy或者循环拷贝.\n\n只是大家想过没有,为什么memcpy那么快,它到底藏了什么魔法?\n\nmemcpy会使用SIMD指令,做多字拷贝.\n\n正常我们写循环拷贝都是按照基础类型本身来进行,单次拷贝可能是在1-4byte之间.但是memcpy按照4byte进行拷贝.所以它的拷贝速度会比较快.\n\n\n\n## SIMD\n\n单指令流多数据流是一种采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元，例如Intel的MMX或SSE，以及AMD的3D Now!指令集。\n\n## 如何比memcpy还快\n\n多线程拷贝\n\n## Reference\n\n1.https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\n\n","slug":"why-memcpy-is-faster-than-others","published":1,"updated":"2023-01-03T08:15:36.426Z","comments":1,"photos":[],"link":"","_id":"clcg0w042000m7dt36gtb5b7z","content":"<p>相信学过c&#x2F;c++的对这个函数都不会陌生.拷贝一段内存时,我们通常会使用memcpy或者循环拷贝.</p>\n<p>只是大家想过没有,为什么memcpy那么快,它到底藏了什么魔法?</p>\n<p>memcpy会使用SIMD指令,做多字拷贝.</p>\n<p>正常我们写循环拷贝都是按照基础类型本身来进行,单次拷贝可能是在1-4byte之间.但是memcpy按照4byte进行拷贝.所以它的拷贝速度会比较快.</p>\n<h2 id=\"SIMD\"><a href=\"#SIMD\" class=\"headerlink\" title=\"SIMD\"></a>SIMD</h2><p>单指令流多数据流是一种采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元，例如Intel的MMX或SSE，以及AMD的3D Now!指令集。</p>\n<h2 id=\"如何比memcpy还快\"><a href=\"#如何比memcpy还快\" class=\"headerlink\" title=\"如何比memcpy还快\"></a>如何比memcpy还快</h2><p>多线程拷贝</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>1.<a href=\"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\">https://en.wikipedia.org/wiki/Single_instruction,_multiple_data</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信学过c&#x2F;c++的对这个函数都不会陌生.拷贝一段内存时,我们通常会使用memcpy或者循环拷贝.</p>\n<p>只是大家想过没有,为什么memcpy那么快,它到底藏了什么魔法?</p>\n<p>memcpy会使用SIMD指令,做多字拷贝.</p>\n<p>正常我们写循环拷贝都是按照基础类型本身来进行,单次拷贝可能是在1-4byte之间.但是memcpy按照4byte进行拷贝.所以它的拷贝速度会比较快.</p>\n<h2 id=\"SIMD\"><a href=\"#SIMD\" class=\"headerlink\" title=\"SIMD\"></a>SIMD</h2><p>单指令流多数据流是一种采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作从而实现空间上的并行性的技术。 在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元，例如Intel的MMX或SSE，以及AMD的3D Now!指令集。</p>\n<h2 id=\"如何比memcpy还快\"><a href=\"#如何比memcpy还快\" class=\"headerlink\" title=\"如何比memcpy还快\"></a>如何比memcpy还快</h2><p>多线程拷贝</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>1.<a href=\"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\">https://en.wikipedia.org/wiki/Single_instruction,_multiple_data</a></p>\n"},{"layout":"post","title":"c++的函数调用栈过程[TODO]","date":"2022-10-31T06:19:58.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"","source":"_posts/2022-10-31-c_cpp_function_call_stack.md","raw":"---\nlayout: post\ntitle: c++的函数调用栈过程[TODO]\ndate: 2022-10-31 14:19:58 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n","slug":"c_cpp_function_call_stack","published":1,"updated":"2023-01-03T08:15:36.426Z","comments":1,"photos":[],"link":"","_id":"clcg0w042000p7dt3avs8bdba","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"c++11的内存模型[TODO]","date":"2022-11-09T08:34:49.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\nC++11的内存模型\n\n","source":"_posts/2022-11-09-cpp11_memory_model.md","raw":"---\nlayout: post\ntitle: c++11的内存模型[TODO]\ndate: 2022-11-09 16:34:49 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\nC++11的内存模型\n\n","slug":"cpp11_memory_model","published":1,"updated":"2023-01-03T08:15:36.427Z","comments":1,"photos":[],"link":"","_id":"clcg0w042000r7dt33h2df716","content":"<p>C++11的内存模型</p>\n","site":{"data":{}},"excerpt":"","more":"<p>C++11的内存模型</p>\n"},{"layout":"post","title":"brpc源码解析ep01——flatmap分析","date":"2022-11-29T07:34:41.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n让我们来看看FlatMap的结构,看明白了FlatMap,那么FlatSet也是手到擒来.\n\n```c++\nclass FlatMap{\n  public:\n    struct PositionHint {\n        size_t nbucket;\n        size_t offset;\n        bool at_entry;\n        key_type key;\n    };\n     struct Bucket {\n        Bucket* next;\n        char element_spaces[sizeof(Element)];\n    };\n  private:\n  \tsize_t _size;\n    size_t _nbucket;\n    Bucket* _buckets;\n    uint64_t* _thumbnail;\n    u_int _load_factor;\n    hasher _hashfn;\n    key_equal _eql;\n    SingleThreadedPool<sizeof(Bucket), 1024, 16> _pool;\n}\n```\n\nFlatMap是一种开链法的hash table.\n\n\n\n## hash函数\n\nFlatMap支持多种hash函数\n\n1.\n","source":"_posts/2022-11-29-brpc_sourcecode_parsing_ep01.md","raw":"---\nlayout: post\ntitle: brpc源码解析ep01——flatmap分析\ndate: 2022-11-29 15:34:41 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\n\n\n让我们来看看FlatMap的结构,看明白了FlatMap,那么FlatSet也是手到擒来.\n\n```c++\nclass FlatMap{\n  public:\n    struct PositionHint {\n        size_t nbucket;\n        size_t offset;\n        bool at_entry;\n        key_type key;\n    };\n     struct Bucket {\n        Bucket* next;\n        char element_spaces[sizeof(Element)];\n    };\n  private:\n  \tsize_t _size;\n    size_t _nbucket;\n    Bucket* _buckets;\n    uint64_t* _thumbnail;\n    u_int _load_factor;\n    hasher _hashfn;\n    key_equal _eql;\n    SingleThreadedPool<sizeof(Bucket), 1024, 16> _pool;\n}\n```\n\nFlatMap是一种开链法的hash table.\n\n\n\n## hash函数\n\nFlatMap支持多种hash函数\n\n1.\n","slug":"brpc_sourcecode_parsing_ep01","published":1,"updated":"2023-01-03T08:15:36.427Z","comments":1,"photos":[],"link":"","_id":"clcg0w043000s7dt3g4qd0iii","content":"<p>让我们来看看FlatMap的结构,看明白了FlatMap,那么FlatSet也是手到擒来.</p>\n<pre><code class=\"c++\">class FlatMap&#123;\n  public:\n    struct PositionHint &#123;\n        size_t nbucket;\n        size_t offset;\n        bool at_entry;\n        key_type key;\n    &#125;;\n     struct Bucket &#123;\n        Bucket* next;\n        char element_spaces[sizeof(Element)];\n    &#125;;\n  private:\n      size_t _size;\n    size_t _nbucket;\n    Bucket* _buckets;\n    uint64_t* _thumbnail;\n    u_int _load_factor;\n    hasher _hashfn;\n    key_equal _eql;\n    SingleThreadedPool&lt;sizeof(Bucket), 1024, 16&gt; _pool;\n&#125;\n</code></pre>\n<p>FlatMap是一种开链法的hash table.</p>\n<h2 id=\"hash函数\"><a href=\"#hash函数\" class=\"headerlink\" title=\"hash函数\"></a>hash函数</h2><p>FlatMap支持多种hash函数</p>\n<ol>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>让我们来看看FlatMap的结构,看明白了FlatMap,那么FlatSet也是手到擒来.</p>\n<pre><code class=\"c++\">class FlatMap&#123;\n  public:\n    struct PositionHint &#123;\n        size_t nbucket;\n        size_t offset;\n        bool at_entry;\n        key_type key;\n    &#125;;\n     struct Bucket &#123;\n        Bucket* next;\n        char element_spaces[sizeof(Element)];\n    &#125;;\n  private:\n      size_t _size;\n    size_t _nbucket;\n    Bucket* _buckets;\n    uint64_t* _thumbnail;\n    u_int _load_factor;\n    hasher _hashfn;\n    key_equal _eql;\n    SingleThreadedPool&lt;sizeof(Bucket), 1024, 16&gt; _pool;\n&#125;\n</code></pre>\n<p>FlatMap是一种开链法的hash table.</p>\n<h2 id=\"hash函数\"><a href=\"#hash函数\" class=\"headerlink\" title=\"hash函数\"></a>hash函数</h2><p>FlatMap支持多种hash函数</p>\n<ol>\n<li></li>\n</ol>\n"},{"layout":"post","title":"linux_kernel_tips[TODO]","date":"2022-12-01T05:10:02.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n## 内核态的进程运行到sleep状态解析\n\nschedule_timeout函数如何让当前进程陷入sleep,主动交出控制权\n\n主要通过调用schedule主动进入调度函数\n\n### Q:进程的数据栈会被回收吗?\n\nA:是的,当进行进程切换时,在xx函数会进行进程清理,把相关现场保存\n\n```c\nschedule_timeout\n//time/timer.c\nsigned long __sched schedule_timeout(signed long timeout)\n//sched/core.c\nasmlinkage __visible void __sched schedule(void){\n\t//call\n  //进入调度器\n  __schedule(SM_NONE);//https://zhuanlan.zhihu.com/p/363791563\n}\n```\n\n## Linux 函数 get_current()\n\n所以通过`esp`寄存器的值和内核栈大小，就可以方便的计算出内核栈的栈底地址，该地址其实就是进程对应的`struct thread_info`结构的地址\n\n//http://linux.laoqinren.net/kernel/sched/current/\n\n```c\nstatic __always_inline struct task_struct *get_current(void)\n{\n\tunsigned long sp_el0;\n\n\tasm (\"mrs %0, sp_el0\" : \"=r\" (sp_el0));\n\n\treturn (struct task_struct *)sp_el0;\n}\n```\n\n","source":"_posts/2022-12-01-linux_kernel_tips.md","raw":"---\nlayout: post\ntitle: linux_kernel_tips[TODO]\ndate: 2022-12-01 13:10:02 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n\n---\n\n\n\n## 内核态的进程运行到sleep状态解析\n\nschedule_timeout函数如何让当前进程陷入sleep,主动交出控制权\n\n主要通过调用schedule主动进入调度函数\n\n### Q:进程的数据栈会被回收吗?\n\nA:是的,当进行进程切换时,在xx函数会进行进程清理,把相关现场保存\n\n```c\nschedule_timeout\n//time/timer.c\nsigned long __sched schedule_timeout(signed long timeout)\n//sched/core.c\nasmlinkage __visible void __sched schedule(void){\n\t//call\n  //进入调度器\n  __schedule(SM_NONE);//https://zhuanlan.zhihu.com/p/363791563\n}\n```\n\n## Linux 函数 get_current()\n\n所以通过`esp`寄存器的值和内核栈大小，就可以方便的计算出内核栈的栈底地址，该地址其实就是进程对应的`struct thread_info`结构的地址\n\n//http://linux.laoqinren.net/kernel/sched/current/\n\n```c\nstatic __always_inline struct task_struct *get_current(void)\n{\n\tunsigned long sp_el0;\n\n\tasm (\"mrs %0, sp_el0\" : \"=r\" (sp_el0));\n\n\treturn (struct task_struct *)sp_el0;\n}\n```\n\n","slug":"linux_kernel_tips","published":1,"updated":"2023-01-03T08:15:36.428Z","comments":1,"photos":[],"link":"","_id":"clcg0w043000u7dt3hcho8gcg","content":"<h2 id=\"内核态的进程运行到sleep状态解析\"><a href=\"#内核态的进程运行到sleep状态解析\" class=\"headerlink\" title=\"内核态的进程运行到sleep状态解析\"></a>内核态的进程运行到sleep状态解析</h2><p>schedule_timeout函数如何让当前进程陷入sleep,主动交出控制权</p>\n<p>主要通过调用schedule主动进入调度函数</p>\n<h3 id=\"Q-进程的数据栈会被回收吗\"><a href=\"#Q-进程的数据栈会被回收吗\" class=\"headerlink\" title=\"Q:进程的数据栈会被回收吗?\"></a>Q:进程的数据栈会被回收吗?</h3><p>A:是的,当进行进程切换时,在xx函数会进行进程清理,把相关现场保存</p>\n<pre><code class=\"c\">schedule_timeout\n//time/timer.c\nsigned long __sched schedule_timeout(signed long timeout)\n//sched/core.c\nasmlinkage __visible void __sched schedule(void)&#123;\n    //call\n  //进入调度器\n  __schedule(SM_NONE);//https://zhuanlan.zhihu.com/p/363791563\n&#125;\n</code></pre>\n<h2 id=\"Linux-函数-get-current\"><a href=\"#Linux-函数-get-current\" class=\"headerlink\" title=\"Linux 函数 get_current()\"></a>Linux 函数 get_current()</h2><p>所以通过<code>esp</code>寄存器的值和内核栈大小，就可以方便的计算出内核栈的栈底地址，该地址其实就是进程对应的<code>struct thread_info</code>结构的地址</p>\n<p>&#x2F;&#x2F;<a href=\"http://linux.laoqinren.net/kernel/sched/current/\">http://linux.laoqinren.net/kernel/sched/current/</a></p>\n<pre><code class=\"c\">static __always_inline struct task_struct *get_current(void)\n&#123;\n    unsigned long sp_el0;\n\n    asm (&quot;mrs %0, sp_el0&quot; : &quot;=r&quot; (sp_el0));\n\n    return (struct task_struct *)sp_el0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内核态的进程运行到sleep状态解析\"><a href=\"#内核态的进程运行到sleep状态解析\" class=\"headerlink\" title=\"内核态的进程运行到sleep状态解析\"></a>内核态的进程运行到sleep状态解析</h2><p>schedule_timeout函数如何让当前进程陷入sleep,主动交出控制权</p>\n<p>主要通过调用schedule主动进入调度函数</p>\n<h3 id=\"Q-进程的数据栈会被回收吗\"><a href=\"#Q-进程的数据栈会被回收吗\" class=\"headerlink\" title=\"Q:进程的数据栈会被回收吗?\"></a>Q:进程的数据栈会被回收吗?</h3><p>A:是的,当进行进程切换时,在xx函数会进行进程清理,把相关现场保存</p>\n<pre><code class=\"c\">schedule_timeout\n//time/timer.c\nsigned long __sched schedule_timeout(signed long timeout)\n//sched/core.c\nasmlinkage __visible void __sched schedule(void)&#123;\n    //call\n  //进入调度器\n  __schedule(SM_NONE);//https://zhuanlan.zhihu.com/p/363791563\n&#125;\n</code></pre>\n<h2 id=\"Linux-函数-get-current\"><a href=\"#Linux-函数-get-current\" class=\"headerlink\" title=\"Linux 函数 get_current()\"></a>Linux 函数 get_current()</h2><p>所以通过<code>esp</code>寄存器的值和内核栈大小，就可以方便的计算出内核栈的栈底地址，该地址其实就是进程对应的<code>struct thread_info</code>结构的地址</p>\n<p>&#x2F;&#x2F;<a href=\"http://linux.laoqinren.net/kernel/sched/current/\">http://linux.laoqinren.net/kernel/sched/current/</a></p>\n<pre><code class=\"c\">static __always_inline struct task_struct *get_current(void)\n&#123;\n    unsigned long sp_el0;\n\n    asm (&quot;mrs %0, sp_el0&quot; : &quot;=r&quot; (sp_el0));\n\n    return (struct task_struct *)sp_el0;\n&#125;\n</code></pre>\n"},{"layout":"post","title":"如何使用vscode优雅地阅读linux代码","date":"2022-12-01T09:53:41.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\n笔者将介绍如何使用vscode阅读Linux内核代码.\n\n1.下载Linux内核\n\n2.进行内核编译\n\n```bash\ntar xvf linux-x.x.x.tar.gz && cd linux-x.x.x\n cp /boot/config-$(uname -r) .config\n //install bear\n bear -- make -j\n```\n\n经过这步骤之后,会生成一个//linux-x.x.x/compile_commands.json\n\n用vscode打开linxu-x.x.x\n\n配置//linxu-x.x.x/.vscode/c_cpp_properties.json\n\n```json\n\"compileCommands\": \"${workspaceFolder}/compile_commands.json\"\n```\n\n3.关闭选项:c/c++ disable error squiggles\n\n4.最后vscode:reload window\n\n5.享受你的阅读\n","source":"_posts/2022-12-01-如何使用vscode优雅地阅读linux代码.md","raw":"---\nlayout: post\ntitle: 如何使用vscode优雅地阅读linux代码\ndate: 2022-12-01 17:53:41 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: [tech]\nauthor: fakecore\nauthor_url: \n---\n\n\n\n笔者将介绍如何使用vscode阅读Linux内核代码.\n\n1.下载Linux内核\n\n2.进行内核编译\n\n```bash\ntar xvf linux-x.x.x.tar.gz && cd linux-x.x.x\n cp /boot/config-$(uname -r) .config\n //install bear\n bear -- make -j\n```\n\n经过这步骤之后,会生成一个//linux-x.x.x/compile_commands.json\n\n用vscode打开linxu-x.x.x\n\n配置//linxu-x.x.x/.vscode/c_cpp_properties.json\n\n```json\n\"compileCommands\": \"${workspaceFolder}/compile_commands.json\"\n```\n\n3.关闭选项:c/c++ disable error squiggles\n\n4.最后vscode:reload window\n\n5.享受你的阅读\n","slug":"如何使用vscode优雅地阅读linux代码","published":1,"updated":"2023-01-03T08:15:36.428Z","comments":1,"photos":[],"link":"","_id":"clcg0w043000v7dt3ber8elqk","content":"<p>笔者将介绍如何使用vscode阅读Linux内核代码.</p>\n<p>1.下载Linux内核</p>\n<p>2.进行内核编译</p>\n<pre><code class=\"bash\">tar xvf linux-x.x.x.tar.gz &amp;&amp; cd linux-x.x.x\n cp /boot/config-$(uname -r) .config\n //install bear\n bear -- make -j\n</code></pre>\n<p>经过这步骤之后,会生成一个&#x2F;&#x2F;linux-x.x.x&#x2F;compile_commands.json</p>\n<p>用vscode打开linxu-x.x.x</p>\n<p>配置&#x2F;&#x2F;linxu-x.x.x&#x2F;.vscode&#x2F;c_cpp_properties.json</p>\n<pre><code class=\"json\">&quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;\n</code></pre>\n<p>3.关闭选项:c&#x2F;c++ disable error squiggles</p>\n<p>4.最后vscode:reload window</p>\n<p>5.享受你的阅读</p>\n","site":{"data":{}},"excerpt":"","more":"<p>笔者将介绍如何使用vscode阅读Linux内核代码.</p>\n<p>1.下载Linux内核</p>\n<p>2.进行内核编译</p>\n<pre><code class=\"bash\">tar xvf linux-x.x.x.tar.gz &amp;&amp; cd linux-x.x.x\n cp /boot/config-$(uname -r) .config\n //install bear\n bear -- make -j\n</code></pre>\n<p>经过这步骤之后,会生成一个&#x2F;&#x2F;linux-x.x.x&#x2F;compile_commands.json</p>\n<p>用vscode打开linxu-x.x.x</p>\n<p>配置&#x2F;&#x2F;linxu-x.x.x&#x2F;.vscode&#x2F;c_cpp_properties.json</p>\n<pre><code class=\"json\">&quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;\n</code></pre>\n<p>3.关闭选项:c&#x2F;c++ disable error squiggles</p>\n<p>4.最后vscode:reload window</p>\n<p>5.享受你的阅读</p>\n"},{"layout":"post","title":"c++的不定参数传递方法","date":"2022-12-02T09:20:00.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"","source":"_posts/2022-12-02-c++的不定参数传递方法.md","raw":"---\nlayout: post\ntitle: c++的不定参数传递方法\ndate: 2022-12-02 17:20:00 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n","slug":"c++的不定参数传递方法","published":1,"updated":"2023-01-03T08:15:36.428Z","comments":1,"photos":[],"link":"","_id":"clcg0w043000w7dt3beo1hf44","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"rust (Rc, RefCell) and( Arc, Mutex)","date":"2022-12-15T06:15:15.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"\n\n\nToday we will introduce (`Rc`, `RefCell`) and( `Arc`, `Mutex`) In advanced Rust programming.\n\n### Rc\\<T>\n\nonly for use in single-threaded scenarios.\n\nRc\\<T> is a reference counter.\n\nT is read-only\n\n### RefCell\\<T>\n\nonly for use in single-threaded scenarios.\n\n*Interior mutability* is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; \n\n### Rc<RefCell\\<T>>\n\nonly for use in single-threaded scenarios.\n\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n```\n\n### Arc\\<T>\n\nFortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in concurrent situations. \n\nArc\\<T>'s counter is atomic, So we can use it in concurrency.\n\n### Mutex\\<T>\n\nlock the variable access permission. thread-safe.\n\n### Arc<Mutex\\<T>> \n\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\ndon't forget implement trait `Send` and `Sync` for T\n\n```Rust\nstruct X{\n}\n\nunsafe impl Sync for X{\n\n}\nunsafe impl Send for X{\n\n}\nArc::new(Mutex::new(X::new()));\n```\n\n","source":"_posts/2022-12-15-rc_and_refcell.md","raw":"---\nlayout: post\ntitle:  rust (Rc, RefCell) and( Arc, Mutex) \ndate: 2022-12-15 14:15:15 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\n\n\nToday we will introduce (`Rc`, `RefCell`) and( `Arc`, `Mutex`) In advanced Rust programming.\n\n### Rc\\<T>\n\nonly for use in single-threaded scenarios.\n\nRc\\<T> is a reference counter.\n\nT is read-only\n\n### RefCell\\<T>\n\nonly for use in single-threaded scenarios.\n\n*Interior mutability* is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; \n\n### Rc<RefCell\\<T>>\n\nonly for use in single-threaded scenarios.\n\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n```\n\n### Arc\\<T>\n\nFortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in concurrent situations. \n\nArc\\<T>'s counter is atomic, So we can use it in concurrency.\n\n### Mutex\\<T>\n\nlock the variable access permission. thread-safe.\n\n### Arc<Mutex\\<T>> \n\n```rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\ndon't forget implement trait `Send` and `Sync` for T\n\n```Rust\nstruct X{\n}\n\nunsafe impl Sync for X{\n\n}\nunsafe impl Send for X{\n\n}\nArc::new(Mutex::new(X::new()));\n```\n\n","slug":"rc_and_refcell","published":1,"updated":"2023-01-03T08:15:36.429Z","comments":1,"photos":[],"link":"","_id":"clcg0w044000y7dt3fo5xbyuu","content":"<p>Today we will introduce (<code>Rc</code>, <code>RefCell</code>) and( <code>Arc</code>, <code>Mutex</code>) In advanced Rust programming.</p>\n<h3 id=\"Rc-lt-T-gt\"><a href=\"#Rc-lt-T-gt\" class=\"headerlink\" title=\"Rc&lt;T&gt;\"></a>Rc&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<p>Rc&lt;T&gt; is a reference counter.</p>\n<p>T is read-only</p>\n<h3 id=\"RefCell-lt-T-gt\"><a href=\"#RefCell-lt-T-gt\" class=\"headerlink\" title=\"RefCell&lt;T&gt;\"></a>RefCell&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; </p>\n<h3 id=\"Rc-lt-RefCell-lt-T-gt-gt\"><a href=\"#Rc-lt-RefCell-lt-T-gt-gt\" class=\"headerlink\" title=\"Rc&lt;RefCell&lt;T&gt;&gt;\"></a>Rc&lt;RefCell&lt;T&gt;&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<pre><code class=\"rust\">#[derive(Debug)]\nenum List &#123;\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n&#125;\n\nuse crate::List::&#123;Cons, Nil&#125;;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() &#123;\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));\n\n    *value.borrow_mut() += 10;\n\n    println!(&quot;a after = &#123;:?&#125;&quot;, a);\n    println!(&quot;b after = &#123;:?&#125;&quot;, b);\n    println!(&quot;c after = &#123;:?&#125;&quot;, c);\n&#125;\n</code></pre>\n<h3 id=\"Arc-lt-T-gt\"><a href=\"#Arc-lt-T-gt\" class=\"headerlink\" title=\"Arc&lt;T&gt;\"></a>Arc&lt;T&gt;</h3><p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in concurrent situations. </p>\n<p>Arc&lt;T&gt;’s counter is atomic, So we can use it in concurrency.</p>\n<h3 id=\"Mutex-lt-T-gt\"><a href=\"#Mutex-lt-T-gt\" class=\"headerlink\" title=\"Mutex&lt;T&gt;\"></a>Mutex&lt;T&gt;</h3><p>lock the variable access permission. thread-safe.</p>\n<h3 id=\"Arc-lt-Mutex-lt-T-gt-gt\"><a href=\"#Arc-lt-Mutex-lt-T-gt-gt\" class=\"headerlink\" title=\"Arc&lt;Mutex&lt;T&gt;&gt;\"></a>Arc&lt;Mutex&lt;T&gt;&gt;</h3><pre><code class=\"rust\">use std::sync::&#123;Arc, Mutex&#125;;\nuse std::thread;\n\nfn main() &#123;\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 &#123;\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || &#123;\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        &#125;);\n        handles.push(handle);\n    &#125;\n\n    for handle in handles &#123;\n        handle.join().unwrap();\n    &#125;\n\n    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());\n&#125;\n</code></pre>\n<p>don’t forget implement trait <code>Send</code> and <code>Sync</code> for T</p>\n<pre><code class=\"Rust\">struct X&#123;\n&#125;\n\nunsafe impl Sync for X&#123;\n\n&#125;\nunsafe impl Send for X&#123;\n\n&#125;\nArc::new(Mutex::new(X::new()));\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Today we will introduce (<code>Rc</code>, <code>RefCell</code>) and( <code>Arc</code>, <code>Mutex</code>) In advanced Rust programming.</p>\n<h3 id=\"Rc-lt-T-gt\"><a href=\"#Rc-lt-T-gt\" class=\"headerlink\" title=\"Rc&lt;T&gt;\"></a>Rc&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<p>Rc&lt;T&gt; is a reference counter.</p>\n<p>T is read-only</p>\n<h3 id=\"RefCell-lt-T-gt\"><a href=\"#RefCell-lt-T-gt\" class=\"headerlink\" title=\"RefCell&lt;T&gt;\"></a>RefCell&lt;T&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; </p>\n<h3 id=\"Rc-lt-RefCell-lt-T-gt-gt\"><a href=\"#Rc-lt-RefCell-lt-T-gt-gt\" class=\"headerlink\" title=\"Rc&lt;RefCell&lt;T&gt;&gt;\"></a>Rc&lt;RefCell&lt;T&gt;&gt;</h3><p>only for use in single-threaded scenarios.</p>\n<pre><code class=\"rust\">#[derive(Debug)]\nenum List &#123;\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n&#125;\n\nuse crate::List::&#123;Cons, Nil&#125;;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() &#123;\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));\n\n    *value.borrow_mut() += 10;\n\n    println!(&quot;a after = &#123;:?&#125;&quot;, a);\n    println!(&quot;b after = &#123;:?&#125;&quot;, b);\n    println!(&quot;c after = &#123;:?&#125;&quot;, c);\n&#125;\n</code></pre>\n<h3 id=\"Arc-lt-T-gt\"><a href=\"#Arc-lt-T-gt\" class=\"headerlink\" title=\"Arc&lt;T&gt;\"></a>Arc&lt;T&gt;</h3><p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in concurrent situations. </p>\n<p>Arc&lt;T&gt;’s counter is atomic, So we can use it in concurrency.</p>\n<h3 id=\"Mutex-lt-T-gt\"><a href=\"#Mutex-lt-T-gt\" class=\"headerlink\" title=\"Mutex&lt;T&gt;\"></a>Mutex&lt;T&gt;</h3><p>lock the variable access permission. thread-safe.</p>\n<h3 id=\"Arc-lt-Mutex-lt-T-gt-gt\"><a href=\"#Arc-lt-Mutex-lt-T-gt-gt\" class=\"headerlink\" title=\"Arc&lt;Mutex&lt;T&gt;&gt;\"></a>Arc&lt;Mutex&lt;T&gt;&gt;</h3><pre><code class=\"rust\">use std::sync::&#123;Arc, Mutex&#125;;\nuse std::thread;\n\nfn main() &#123;\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 &#123;\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || &#123;\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        &#125;);\n        handles.push(handle);\n    &#125;\n\n    for handle in handles &#123;\n        handle.join().unwrap();\n    &#125;\n\n    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());\n&#125;\n</code></pre>\n<p>don’t forget implement trait <code>Send</code> and <code>Sync</code> for T</p>\n<pre><code class=\"Rust\">struct X&#123;\n&#125;\n\nunsafe impl Sync for X&#123;\n\n&#125;\nunsafe impl Send for X&#123;\n\n&#125;\nArc::new(Mutex::new(X::new()));\n</code></pre>\n"},{"layout":"post","title":"linux的共享内存介绍,简单使用","date":"2022-12-14T06:01:50.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"","source":"_posts/2022-12-14-linux的共享内存介绍,简单使用.md","raw":"---\nlayout: post\ntitle: linux的共享内存介绍,简单使用\ndate: 2022-12-14 14:01:50 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n","slug":"linux的共享内存介绍,简单使用","published":1,"updated":"2023-01-03T08:15:36.429Z","comments":1,"photos":[],"link":"","_id":"clcg0w044000z7dt33dk570o7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"分布式一致性协议解析Paxos,Raft等","date":"2022-12-09T05:42:37.000Z","last_modified_at":"2022-12-16 17:21:05 +0800","author":"fakecore","author_url":null,"_content":"","source":"_posts/2022-12-09-从Paxos,Raft等来看分布式一致性协议.md","raw":"---\nlayout: post\ntitle: 分布式一致性协议解析Paxos,Raft等\ndate: 2022-12-09 13:42:37 +0800\nlast_modified_at: 2022-12-16 17:21:05 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n","slug":"从Paxos,Raft等来看分布式一致性协议","published":1,"updated":"2023-01-03T08:15:36.429Z","comments":1,"photos":[],"link":"","_id":"clcg0w04400107dt31i4ohu3r","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"shm与mmap","date":"2023-01-03T05:53:36.000Z","last_modified_at":"2023-01-03 15:36:11 +0800","author":"fakecore","author_url":null,"_content":"\nshmget 和 shm_open+mmap是两种不同的共享内存用法,\n\nshmget是老式system V 模型,\n\nshm_open 是POSIX下的产物.\n\nmmap和System V共享内存的主要区别在于：\n\n- sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；\n- mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。\n\n内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。\n\n- 匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。\n- 文件映射有`MAP_PRIVATE`和`MAP_SHARED`两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。\n\nshmget用法 shmget(IPC_PRIVATE,size,flag)\n\nshm_open 创建一个共享内存(文件,/dev/shm下),返回一个fd.通过ftruncate指定文件大小\n\nmmap通过fd attach上这个地址,进行操作\n\n## shmget\n\ncompared to shm_open+mmap, shm_get used the old System V shared memory model.\n\n```c\n#include <sys/ipc.h>\n#include <sys/shm.h>\nint shmget(key_t key, size_t size, int shmflg);\n```\n\nkey: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.\n\n获取一个特定shm\n\nsize: A new shared memory segment, with size equal to the value of size rounded up to a  multi-\n       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn't IPC_PRIVATE,\n       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-\n       flg.\n\n If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-\n       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the\n       effect of the combination O_CREAT | O_EXCL for open(2).)\n\n如果shmflag同时指定了`IPC_CREAT` 和`IPC_EXCL`,同时有一个已存在的KEY共享内存,shmget将会失败.\n\nRETURN VALUE\n       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and\n       errno is set to indicate the error.\n\n可以理解成返回一个fd,指向可用的shm segement\n\n\n\n## shm_open+mmap\n\n```c\n#include <sys/mman.h>\n#include <sys/stat.h>        /* For mode constants */\n#include <fcntl.h>           /* For O_* constants */\n\nint shm_open(const char *name, int oflag, mode_t mode);\n\nint shm_unlink(const char *name);\n\nLink with -lrt.\n```\n\nshm_open: 可以创建或者打开已存在的shm segement.\n\n`open` is the same as `shm_open`.\n\nshm_unlink: 关闭shm segement\n\n **oflag** is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any\n       of the other flags listed here:\n\n       O_RDONLY\n              Open the object for read access.  A shared memory object opened in this way can be\n              mmap(2)ed only for read (PROT_READ) access.\n    \n       O_RDWR Open the object for read-write access.\n    \n       O_CREAT\n              Create the shared memory object if it does not exist.  The user and  group  owner-\n              ship  of  the object are taken from the corresponding effective IDs of the calling\n              process, and the object's permission bits are set according  to  the  low-order  9\n              bits  of  mode,  except that those bits set in the process file mode creation mask\n              (see umask(2)) are cleared for the new object.  A set of macro constants which can\n              be  used to define mode is listed in open(2).  (Symbolic definitions of these con-\n              stants can be obtained by including <sys/stat.h>.)\n    \n              A new shared memory object initially has zero length--the size of the  object  can\n              be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object\n              are automatically initialized to 0.\n    \n       O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-\n              ready exists, return an error.  The check for the existence of the object, and its\n              creation if it does not exist, are performed atomically.\n    \n       O_TRUNC\n              If the shared memory object already exists, truncate it to zero bytes.\n\n**mmap**\n\n```c\n #include <sys/mman.h>\n\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n           int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n//See NOTES for information on feature test macro requirements.\n```\n\n```\nmmap() creates a new mapping in the virtual address space of the\n       calling process.  The starting address for the new mapping is\n       specified in addr.  The length argument specifies the length of\n       the mapping (which must be greater than 0).\n\nRETURN VALUE\nOn success, mmap() returns a pointer to the mapped area.  On\n       error, the value MAP_FAILED (that is, (void *) -1) is returned,\n       and errno is set to indicate the error.\n\nOn success, munmap() returns 0.  On failure, it returns -1, and\nerrno is set to indicate the error (probably to EINVAL).\n```\n\n**ftruncate**\n\n把文件size变到指定大小\n\n```c\n#include <unistd.h>\n#include <sys/types.h>\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);\n```\n\n    The truncate()  and ftruncate() functions cause the regular file named by path or refer-\n           enced by fd to be truncated to a size of precisely length bytes.\n     \n    If the file previously was larger than this size, the extra data is lost.   If  the  file\n       previously was shorter, it is extended, and the extended part reads as null bytes ('\\0').\n    \n       The file offset is not changed.\n    \n       If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last\n       status change and time of last modification; see inode(7)) for the file are updated,  and\n       the set-user-ID and set-group-ID mode bits may be cleared.\n    \n       With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be\n       writable.\n\nsimply code\n\n```c\n//get.c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n\n#define STORAGE_ID \"/SHM_TEST\"\n#define STORAGE_SIZE 32\n\nint main(int argc, char *argv[])\n{\n\tint res;\n\tint fd;\n\tchar data[STORAGE_SIZE];\n\tpid_t pid;\n\tvoid *addr;\n\n\tpid = getpid();\n\n\t// get shared memory file descriptor (NOT a file,but act as a regular file)\n\tfd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t{\n\t\tperror(\"open\");\n\t\treturn 10;\n\t}\n\n\t// map shared memory to process address space\n\taddr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED)\n\t{\n\t\tperror(\"mmap\");\n\t\treturn 30;\n\t}\n\n\t// place data into memory\n\tmemcpy(data, addr, STORAGE_SIZE);\n\n\tprintf(\"PID %d: Read from shared memory: \\\"%s\\\"\\n\", pid, data);\n\n\treturn 0;\n}\n```\n\n```c\n//set.c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n\n#define STORAGE_ID \"/SHM_TEST\"\n#define STORAGE_SIZE 32\n#define DATA \"Hello, World! From PID %d\"\n\nint main(int argc, char *argv[])\n{\n\tint res;\n\tint fd;\n\tint len;\n\tpid_t pid;\n\tvoid *addr;\n\tchar data[STORAGE_SIZE];\n\n\tpid = getpid();\n\tsprintf(data, DATA, pid);\n\n\t// get shared memory file descriptor (NOT a file)\n\tfd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t{\n\t\tperror(\"open\");\n\t\treturn 10;\n\t}\n\n\t// extend shared memory object as by default it's initialized with size 0\n\tres = ftruncate(fd, STORAGE_SIZE);\n\tif (res == -1)\n\t{\n\t\tperror(\"ftruncate\");\n\t\treturn 20;\n\t}\n\n\t// map shared memory to process address space\n\taddr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED)\n\t{\n\t\tperror(\"mmap\");\n\t\treturn 30;\n\t}\n\n\t// place data into memory\n\tlen = strlen(data) + 1;\n\tmemcpy(addr, data, len);\n\n\t// wait for someone to read it\n\tsleep(2);\n\n\t// mmap cleanup\n\tres = munmap(addr, STORAGE_SIZE);\n\tif (res == -1)\n\t{\n\t\tperror(\"munmap\");\n\t\treturn 40;\n\t}\n\n\t// shm_open cleanup\n\tfd = shm_unlink(STORAGE_ID);\n\tif (fd == -1)\n\t{\n\t\tperror(\"unlink\");\n\t\treturn 100;\n\t}\n\n\treturn 0;\n}\n```\n\n## 题外话 Q&A:\n\n### Q:mmap下的资源需要锁吗?\n\nA:\n\n需要锁:\n\n**Semaphores**\n\n**共享内存的**mutex\n\n​\tpthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致\n\n如何使用?\n\n通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息\n\nhttps://blog.csdn.net/qq_35396127/article/details/78942245\n\n\n\n**文件锁**\n\n在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust\n\n\n\n### Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink\n\nA:\n\nThe operation of **shm_unlink**() is analogous to ***[unlink](https://linux.die.net/man/2/unlink)**(2)*: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful **shm_unlink**(), attempts to **shm_open**() an object with the same *name* will fail (unless **O_CREAT** was specified, in which case a new, distinct object is created).\n\n文件存在于/dev/shm下,如果不调用该函数,文件会一直存在\n","source":"_posts/2023-01-03-shm-mmap.md","raw":"---\nlayout: post\ntitle: shm与mmap\ndate: 2023-01-03 13:53:36 +0800\nlast_modified_at: 2023-01-03 15:36:11 +0800\ntags: []\nauthor: fakecore\nauthor_url: \n---\n\nshmget 和 shm_open+mmap是两种不同的共享内存用法,\n\nshmget是老式system V 模型,\n\nshm_open 是POSIX下的产物.\n\nmmap和System V共享内存的主要区别在于：\n\n- sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；\n- mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。\n\n内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。\n\n- 匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。\n- 文件映射有`MAP_PRIVATE`和`MAP_SHARED`两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。\n\nshmget用法 shmget(IPC_PRIVATE,size,flag)\n\nshm_open 创建一个共享内存(文件,/dev/shm下),返回一个fd.通过ftruncate指定文件大小\n\nmmap通过fd attach上这个地址,进行操作\n\n## shmget\n\ncompared to shm_open+mmap, shm_get used the old System V shared memory model.\n\n```c\n#include <sys/ipc.h>\n#include <sys/shm.h>\nint shmget(key_t key, size_t size, int shmflg);\n```\n\nkey: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.\n\n获取一个特定shm\n\nsize: A new shared memory segment, with size equal to the value of size rounded up to a  multi-\n       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn't IPC_PRIVATE,\n       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-\n       flg.\n\n If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-\n       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the\n       effect of the combination O_CREAT | O_EXCL for open(2).)\n\n如果shmflag同时指定了`IPC_CREAT` 和`IPC_EXCL`,同时有一个已存在的KEY共享内存,shmget将会失败.\n\nRETURN VALUE\n       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and\n       errno is set to indicate the error.\n\n可以理解成返回一个fd,指向可用的shm segement\n\n\n\n## shm_open+mmap\n\n```c\n#include <sys/mman.h>\n#include <sys/stat.h>        /* For mode constants */\n#include <fcntl.h>           /* For O_* constants */\n\nint shm_open(const char *name, int oflag, mode_t mode);\n\nint shm_unlink(const char *name);\n\nLink with -lrt.\n```\n\nshm_open: 可以创建或者打开已存在的shm segement.\n\n`open` is the same as `shm_open`.\n\nshm_unlink: 关闭shm segement\n\n **oflag** is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any\n       of the other flags listed here:\n\n       O_RDONLY\n              Open the object for read access.  A shared memory object opened in this way can be\n              mmap(2)ed only for read (PROT_READ) access.\n    \n       O_RDWR Open the object for read-write access.\n    \n       O_CREAT\n              Create the shared memory object if it does not exist.  The user and  group  owner-\n              ship  of  the object are taken from the corresponding effective IDs of the calling\n              process, and the object's permission bits are set according  to  the  low-order  9\n              bits  of  mode,  except that those bits set in the process file mode creation mask\n              (see umask(2)) are cleared for the new object.  A set of macro constants which can\n              be  used to define mode is listed in open(2).  (Symbolic definitions of these con-\n              stants can be obtained by including <sys/stat.h>.)\n    \n              A new shared memory object initially has zero length--the size of the  object  can\n              be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object\n              are automatically initialized to 0.\n    \n       O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-\n              ready exists, return an error.  The check for the existence of the object, and its\n              creation if it does not exist, are performed atomically.\n    \n       O_TRUNC\n              If the shared memory object already exists, truncate it to zero bytes.\n\n**mmap**\n\n```c\n #include <sys/mman.h>\n\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n           int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n//See NOTES for information on feature test macro requirements.\n```\n\n```\nmmap() creates a new mapping in the virtual address space of the\n       calling process.  The starting address for the new mapping is\n       specified in addr.  The length argument specifies the length of\n       the mapping (which must be greater than 0).\n\nRETURN VALUE\nOn success, mmap() returns a pointer to the mapped area.  On\n       error, the value MAP_FAILED (that is, (void *) -1) is returned,\n       and errno is set to indicate the error.\n\nOn success, munmap() returns 0.  On failure, it returns -1, and\nerrno is set to indicate the error (probably to EINVAL).\n```\n\n**ftruncate**\n\n把文件size变到指定大小\n\n```c\n#include <unistd.h>\n#include <sys/types.h>\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);\n```\n\n    The truncate()  and ftruncate() functions cause the regular file named by path or refer-\n           enced by fd to be truncated to a size of precisely length bytes.\n     \n    If the file previously was larger than this size, the extra data is lost.   If  the  file\n       previously was shorter, it is extended, and the extended part reads as null bytes ('\\0').\n    \n       The file offset is not changed.\n    \n       If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last\n       status change and time of last modification; see inode(7)) for the file are updated,  and\n       the set-user-ID and set-group-ID mode bits may be cleared.\n    \n       With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be\n       writable.\n\nsimply code\n\n```c\n//get.c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n\n#define STORAGE_ID \"/SHM_TEST\"\n#define STORAGE_SIZE 32\n\nint main(int argc, char *argv[])\n{\n\tint res;\n\tint fd;\n\tchar data[STORAGE_SIZE];\n\tpid_t pid;\n\tvoid *addr;\n\n\tpid = getpid();\n\n\t// get shared memory file descriptor (NOT a file,but act as a regular file)\n\tfd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t{\n\t\tperror(\"open\");\n\t\treturn 10;\n\t}\n\n\t// map shared memory to process address space\n\taddr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED)\n\t{\n\t\tperror(\"mmap\");\n\t\treturn 30;\n\t}\n\n\t// place data into memory\n\tmemcpy(data, addr, STORAGE_SIZE);\n\n\tprintf(\"PID %d: Read from shared memory: \\\"%s\\\"\\n\", pid, data);\n\n\treturn 0;\n}\n```\n\n```c\n//set.c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n\n#define STORAGE_ID \"/SHM_TEST\"\n#define STORAGE_SIZE 32\n#define DATA \"Hello, World! From PID %d\"\n\nint main(int argc, char *argv[])\n{\n\tint res;\n\tint fd;\n\tint len;\n\tpid_t pid;\n\tvoid *addr;\n\tchar data[STORAGE_SIZE];\n\n\tpid = getpid();\n\tsprintf(data, DATA, pid);\n\n\t// get shared memory file descriptor (NOT a file)\n\tfd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t{\n\t\tperror(\"open\");\n\t\treturn 10;\n\t}\n\n\t// extend shared memory object as by default it's initialized with size 0\n\tres = ftruncate(fd, STORAGE_SIZE);\n\tif (res == -1)\n\t{\n\t\tperror(\"ftruncate\");\n\t\treturn 20;\n\t}\n\n\t// map shared memory to process address space\n\taddr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED)\n\t{\n\t\tperror(\"mmap\");\n\t\treturn 30;\n\t}\n\n\t// place data into memory\n\tlen = strlen(data) + 1;\n\tmemcpy(addr, data, len);\n\n\t// wait for someone to read it\n\tsleep(2);\n\n\t// mmap cleanup\n\tres = munmap(addr, STORAGE_SIZE);\n\tif (res == -1)\n\t{\n\t\tperror(\"munmap\");\n\t\treturn 40;\n\t}\n\n\t// shm_open cleanup\n\tfd = shm_unlink(STORAGE_ID);\n\tif (fd == -1)\n\t{\n\t\tperror(\"unlink\");\n\t\treturn 100;\n\t}\n\n\treturn 0;\n}\n```\n\n## 题外话 Q&A:\n\n### Q:mmap下的资源需要锁吗?\n\nA:\n\n需要锁:\n\n**Semaphores**\n\n**共享内存的**mutex\n\n​\tpthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致\n\n如何使用?\n\n通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息\n\nhttps://blog.csdn.net/qq_35396127/article/details/78942245\n\n\n\n**文件锁**\n\n在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust\n\n\n\n### Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink\n\nA:\n\nThe operation of **shm_unlink**() is analogous to ***[unlink](https://linux.die.net/man/2/unlink)**(2)*: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful **shm_unlink**(), attempts to **shm_open**() an object with the same *name* will fail (unless **O_CREAT** was specified, in which case a new, distinct object is created).\n\n文件存在于/dev/shm下,如果不调用该函数,文件会一直存在\n","slug":"shm-mmap","published":1,"updated":"2023-01-03T08:15:36.430Z","comments":1,"photos":[],"link":"","_id":"clcg0w04400117dt378475wxi","content":"<p>shmget 和 shm_open+mmap是两种不同的共享内存用法,</p>\n<p>shmget是老式system V 模型,</p>\n<p>shm_open 是POSIX下的产物.</p>\n<p>mmap和System V共享内存的主要区别在于：</p>\n<ul>\n<li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li>\n<li>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。</li>\n</ul>\n<p>内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。</p>\n<ul>\n<li>匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。</li>\n<li>文件映射有<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code>两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。</li>\n</ul>\n<p>shmget用法 shmget(IPC_PRIVATE,size,flag)</p>\n<p>shm_open 创建一个共享内存(文件,&#x2F;dev&#x2F;shm下),返回一个fd.通过ftruncate指定文件大小</p>\n<p>mmap通过fd attach上这个地址,进行操作</p>\n<h2 id=\"shmget\"><a href=\"#shmget\" class=\"headerlink\" title=\"shmget\"></a>shmget</h2><p>compared to shm_open+mmap, shm_get used the old System V shared memory model.</p>\n<pre><code class=\"c\">#include &lt;sys/ipc.h&gt;\n#include &lt;sys/shm.h&gt;\nint shmget(key_t key, size_t size, int shmflg);\n</code></pre>\n<p>key: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.</p>\n<p>获取一个特定shm</p>\n<p>size: A new shared memory segment, with size equal to the value of size rounded up to a  multi-<br>       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE,<br>       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-<br>       flg.</p>\n<p> If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-<br>       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the<br>       effect of the combination O_CREAT | O_EXCL for open(2).)</p>\n<p>如果shmflag同时指定了<code>IPC_CREAT</code> 和<code>IPC_EXCL</code>,同时有一个已存在的KEY共享内存,shmget将会失败.</p>\n<p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and<br>       errno is set to indicate the error.</p>\n<p>可以理解成返回一个fd,指向可用的shm segement</p>\n<h2 id=\"shm-open-mmap\"><a href=\"#shm-open-mmap\" class=\"headerlink\" title=\"shm_open+mmap\"></a>shm_open+mmap</h2><pre><code class=\"c\">#include &lt;sys/mman.h&gt;\n#include &lt;sys/stat.h&gt;        /* For mode constants */\n#include &lt;fcntl.h&gt;           /* For O_* constants */\n\nint shm_open(const char *name, int oflag, mode_t mode);\n\nint shm_unlink(const char *name);\n\nLink with -lrt.\n</code></pre>\n<p>shm_open: 可以创建或者打开已存在的shm segement.</p>\n<p><code>open</code> is the same as <code>shm_open</code>.</p>\n<p>shm_unlink: 关闭shm segement</p>\n<p> <strong>oflag</strong> is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any<br>       of the other flags listed here:</p>\n<pre><code>   O_RDONLY\n          Open the object for read access.  A shared memory object opened in this way can be\n          mmap(2)ed only for read (PROT_READ) access.\n\n   O_RDWR Open the object for read-write access.\n\n   O_CREAT\n          Create the shared memory object if it does not exist.  The user and  group  owner-\n          ship  of  the object are taken from the corresponding effective IDs of the calling\n          process, and the object&#39;s permission bits are set according  to  the  low-order  9\n          bits  of  mode,  except that those bits set in the process file mode creation mask\n          (see umask(2)) are cleared for the new object.  A set of macro constants which can\n          be  used to define mode is listed in open(2).  (Symbolic definitions of these con-\n          stants can be obtained by including &lt;sys/stat.h&gt;.)\n\n          A new shared memory object initially has zero length--the size of the  object  can\n          be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object\n          are automatically initialized to 0.\n\n   O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-\n          ready exists, return an error.  The check for the existence of the object, and its\n          creation if it does not exist, are performed atomically.\n\n   O_TRUNC\n          If the shared memory object already exists, truncate it to zero bytes.\n</code></pre>\n<p><strong>mmap</strong></p>\n<pre><code class=\"c\"> #include &lt;sys/mman.h&gt;\n\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n           int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n//See NOTES for information on feature test macro requirements.\n</code></pre>\n<pre><code>mmap() creates a new mapping in the virtual address space of the\n       calling process.  The starting address for the new mapping is\n       specified in addr.  The length argument specifies the length of\n       the mapping (which must be greater than 0).\n\nRETURN VALUE\nOn success, mmap() returns a pointer to the mapped area.  On\n       error, the value MAP_FAILED (that is, (void *) -1) is returned,\n       and errno is set to indicate the error.\n\nOn success, munmap() returns 0.  On failure, it returns -1, and\nerrno is set to indicate the error (probably to EINVAL).\n</code></pre>\n<p><strong>ftruncate</strong></p>\n<p>把文件size变到指定大小</p>\n<pre><code class=\"c\">#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);\n</code></pre>\n<pre><code>The truncate()  and ftruncate() functions cause the regular file named by path or refer-\n       enced by fd to be truncated to a size of precisely length bytes.\n \nIf the file previously was larger than this size, the extra data is lost.   If  the  file\n   previously was shorter, it is extended, and the extended part reads as null bytes (&#39;\\0&#39;).\n\n   The file offset is not changed.\n\n   If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last\n   status change and time of last modification; see inode(7)) for the file are updated,  and\n   the set-user-ID and set-group-ID mode bits may be cleared.\n\n   With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be\n   writable.\n</code></pre>\n<p>simply code</p>\n<pre><code class=\"c\">//get.c\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n#define STORAGE_ID &quot;/SHM_TEST&quot;\n#define STORAGE_SIZE 32\n\nint main(int argc, char *argv[])\n&#123;\n    int res;\n    int fd;\n    char data[STORAGE_SIZE];\n    pid_t pid;\n    void *addr;\n\n    pid = getpid();\n\n    // get shared memory file descriptor (NOT a file,but act as a regular file)\n    fd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n    &#123;\n        perror(&quot;open&quot;);\n        return 10;\n    &#125;\n\n    // map shared memory to process address space\n    addr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n    &#123;\n        perror(&quot;mmap&quot;);\n        return 30;\n    &#125;\n\n    // place data into memory\n    memcpy(data, addr, STORAGE_SIZE);\n\n    printf(&quot;PID %d: Read from shared memory: \\&quot;%s\\&quot;\\n&quot;, pid, data);\n\n    return 0;\n&#125;\n</code></pre>\n<pre><code class=\"c\">//set.c\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n#define STORAGE_ID &quot;/SHM_TEST&quot;\n#define STORAGE_SIZE 32\n#define DATA &quot;Hello, World! From PID %d&quot;\n\nint main(int argc, char *argv[])\n&#123;\n    int res;\n    int fd;\n    int len;\n    pid_t pid;\n    void *addr;\n    char data[STORAGE_SIZE];\n\n    pid = getpid();\n    sprintf(data, DATA, pid);\n\n    // get shared memory file descriptor (NOT a file)\n    fd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n    &#123;\n        perror(&quot;open&quot;);\n        return 10;\n    &#125;\n\n    // extend shared memory object as by default it&#39;s initialized with size 0\n    res = ftruncate(fd, STORAGE_SIZE);\n    if (res == -1)\n    &#123;\n        perror(&quot;ftruncate&quot;);\n        return 20;\n    &#125;\n\n    // map shared memory to process address space\n    addr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n    &#123;\n        perror(&quot;mmap&quot;);\n        return 30;\n    &#125;\n\n    // place data into memory\n    len = strlen(data) + 1;\n    memcpy(addr, data, len);\n\n    // wait for someone to read it\n    sleep(2);\n\n    // mmap cleanup\n    res = munmap(addr, STORAGE_SIZE);\n    if (res == -1)\n    &#123;\n        perror(&quot;munmap&quot;);\n        return 40;\n    &#125;\n\n    // shm_open cleanup\n    fd = shm_unlink(STORAGE_ID);\n    if (fd == -1)\n    &#123;\n        perror(&quot;unlink&quot;);\n        return 100;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"题外话-Q-amp-A\"><a href=\"#题外话-Q-amp-A\" class=\"headerlink\" title=\"题外话 Q&amp;A:\"></a>题外话 Q&amp;A:</h2><h3 id=\"Q-mmap下的资源需要锁吗\"><a href=\"#Q-mmap下的资源需要锁吗\" class=\"headerlink\" title=\"Q:mmap下的资源需要锁吗?\"></a>Q:mmap下的资源需要锁吗?</h3><p>A:</p>\n<p>需要锁:</p>\n<p><strong>Semaphores</strong></p>\n<p><strong>共享内存的</strong>mutex</p>\n<p>​\tpthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致</p>\n<p>如何使用?</p>\n<p>通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息</p>\n<p><a href=\"https://blog.csdn.net/qq_35396127/article/details/78942245\">https://blog.csdn.net/qq_35396127/article/details/78942245</a></p>\n<p><strong>文件锁</strong></p>\n<p>在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust</p>\n<h3 id=\"Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink\"><a href=\"#Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink\" class=\"headerlink\" title=\"Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink\"></a>Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink</h3><p>A:</p>\n<p>The operation of <strong>shm_unlink</strong>() is analogous to <em><strong><a href=\"https://linux.die.net/man/2/unlink\">unlink</a></strong>(2)</em>: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful <strong>shm_unlink</strong>(), attempts to <strong>shm_open</strong>() an object with the same <em>name</em> will fail (unless <strong>O_CREAT</strong> was specified, in which case a new, distinct object is created).</p>\n<p>文件存在于&#x2F;dev&#x2F;shm下,如果不调用该函数,文件会一直存在</p>\n","site":{"data":{}},"excerpt":"","more":"<p>shmget 和 shm_open+mmap是两种不同的共享内存用法,</p>\n<p>shmget是老式system V 模型,</p>\n<p>shm_open 是POSIX下的产物.</p>\n<p>mmap和System V共享内存的主要区别在于：</p>\n<ul>\n<li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li>\n<li>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。</li>\n</ul>\n<p>内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。</p>\n<ul>\n<li>匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。</li>\n<li>文件映射有<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code>两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。</li>\n</ul>\n<p>shmget用法 shmget(IPC_PRIVATE,size,flag)</p>\n<p>shm_open 创建一个共享内存(文件,&#x2F;dev&#x2F;shm下),返回一个fd.通过ftruncate指定文件大小</p>\n<p>mmap通过fd attach上这个地址,进行操作</p>\n<h2 id=\"shmget\"><a href=\"#shmget\" class=\"headerlink\" title=\"shmget\"></a>shmget</h2><p>compared to shm_open+mmap, shm_get used the old System V shared memory model.</p>\n<pre><code class=\"c\">#include &lt;sys/ipc.h&gt;\n#include &lt;sys/shm.h&gt;\nint shmget(key_t key, size_t size, int shmflg);\n</code></pre>\n<p>key: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.</p>\n<p>获取一个特定shm</p>\n<p>size: A new shared memory segment, with size equal to the value of size rounded up to a  multi-<br>       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE,<br>       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-<br>       flg.</p>\n<p> If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-<br>       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the<br>       effect of the combination O_CREAT | O_EXCL for open(2).)</p>\n<p>如果shmflag同时指定了<code>IPC_CREAT</code> 和<code>IPC_EXCL</code>,同时有一个已存在的KEY共享内存,shmget将会失败.</p>\n<p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and<br>       errno is set to indicate the error.</p>\n<p>可以理解成返回一个fd,指向可用的shm segement</p>\n<h2 id=\"shm-open-mmap\"><a href=\"#shm-open-mmap\" class=\"headerlink\" title=\"shm_open+mmap\"></a>shm_open+mmap</h2><pre><code class=\"c\">#include &lt;sys/mman.h&gt;\n#include &lt;sys/stat.h&gt;        /* For mode constants */\n#include &lt;fcntl.h&gt;           /* For O_* constants */\n\nint shm_open(const char *name, int oflag, mode_t mode);\n\nint shm_unlink(const char *name);\n\nLink with -lrt.\n</code></pre>\n<p>shm_open: 可以创建或者打开已存在的shm segement.</p>\n<p><code>open</code> is the same as <code>shm_open</code>.</p>\n<p>shm_unlink: 关闭shm segement</p>\n<p> <strong>oflag</strong> is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any<br>       of the other flags listed here:</p>\n<pre><code>   O_RDONLY\n          Open the object for read access.  A shared memory object opened in this way can be\n          mmap(2)ed only for read (PROT_READ) access.\n\n   O_RDWR Open the object for read-write access.\n\n   O_CREAT\n          Create the shared memory object if it does not exist.  The user and  group  owner-\n          ship  of  the object are taken from the corresponding effective IDs of the calling\n          process, and the object&#39;s permission bits are set according  to  the  low-order  9\n          bits  of  mode,  except that those bits set in the process file mode creation mask\n          (see umask(2)) are cleared for the new object.  A set of macro constants which can\n          be  used to define mode is listed in open(2).  (Symbolic definitions of these con-\n          stants can be obtained by including &lt;sys/stat.h&gt;.)\n\n          A new shared memory object initially has zero length--the size of the  object  can\n          be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object\n          are automatically initialized to 0.\n\n   O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-\n          ready exists, return an error.  The check for the existence of the object, and its\n          creation if it does not exist, are performed atomically.\n\n   O_TRUNC\n          If the shared memory object already exists, truncate it to zero bytes.\n</code></pre>\n<p><strong>mmap</strong></p>\n<pre><code class=\"c\"> #include &lt;sys/mman.h&gt;\n\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n           int fd, off_t offset);\nint munmap(void *addr, size_t length);\n\n//See NOTES for information on feature test macro requirements.\n</code></pre>\n<pre><code>mmap() creates a new mapping in the virtual address space of the\n       calling process.  The starting address for the new mapping is\n       specified in addr.  The length argument specifies the length of\n       the mapping (which must be greater than 0).\n\nRETURN VALUE\nOn success, mmap() returns a pointer to the mapped area.  On\n       error, the value MAP_FAILED (that is, (void *) -1) is returned,\n       and errno is set to indicate the error.\n\nOn success, munmap() returns 0.  On failure, it returns -1, and\nerrno is set to indicate the error (probably to EINVAL).\n</code></pre>\n<p><strong>ftruncate</strong></p>\n<p>把文件size变到指定大小</p>\n<pre><code class=\"c\">#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);\n</code></pre>\n<pre><code>The truncate()  and ftruncate() functions cause the regular file named by path or refer-\n       enced by fd to be truncated to a size of precisely length bytes.\n \nIf the file previously was larger than this size, the extra data is lost.   If  the  file\n   previously was shorter, it is extended, and the extended part reads as null bytes (&#39;\\0&#39;).\n\n   The file offset is not changed.\n\n   If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last\n   status change and time of last modification; see inode(7)) for the file are updated,  and\n   the set-user-ID and set-group-ID mode bits may be cleared.\n\n   With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be\n   writable.\n</code></pre>\n<p>simply code</p>\n<pre><code class=\"c\">//get.c\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n#define STORAGE_ID &quot;/SHM_TEST&quot;\n#define STORAGE_SIZE 32\n\nint main(int argc, char *argv[])\n&#123;\n    int res;\n    int fd;\n    char data[STORAGE_SIZE];\n    pid_t pid;\n    void *addr;\n\n    pid = getpid();\n\n    // get shared memory file descriptor (NOT a file,but act as a regular file)\n    fd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n    &#123;\n        perror(&quot;open&quot;);\n        return 10;\n    &#125;\n\n    // map shared memory to process address space\n    addr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n    &#123;\n        perror(&quot;mmap&quot;);\n        return 30;\n    &#125;\n\n    // place data into memory\n    memcpy(data, addr, STORAGE_SIZE);\n\n    printf(&quot;PID %d: Read from shared memory: \\&quot;%s\\&quot;\\n&quot;, pid, data);\n\n    return 0;\n&#125;\n</code></pre>\n<pre><code class=\"c\">//set.c\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n#define STORAGE_ID &quot;/SHM_TEST&quot;\n#define STORAGE_SIZE 32\n#define DATA &quot;Hello, World! From PID %d&quot;\n\nint main(int argc, char *argv[])\n&#123;\n    int res;\n    int fd;\n    int len;\n    pid_t pid;\n    void *addr;\n    char data[STORAGE_SIZE];\n\n    pid = getpid();\n    sprintf(data, DATA, pid);\n\n    // get shared memory file descriptor (NOT a file)\n    fd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n    &#123;\n        perror(&quot;open&quot;);\n        return 10;\n    &#125;\n\n    // extend shared memory object as by default it&#39;s initialized with size 0\n    res = ftruncate(fd, STORAGE_SIZE);\n    if (res == -1)\n    &#123;\n        perror(&quot;ftruncate&quot;);\n        return 20;\n    &#125;\n\n    // map shared memory to process address space\n    addr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n    &#123;\n        perror(&quot;mmap&quot;);\n        return 30;\n    &#125;\n\n    // place data into memory\n    len = strlen(data) + 1;\n    memcpy(addr, data, len);\n\n    // wait for someone to read it\n    sleep(2);\n\n    // mmap cleanup\n    res = munmap(addr, STORAGE_SIZE);\n    if (res == -1)\n    &#123;\n        perror(&quot;munmap&quot;);\n        return 40;\n    &#125;\n\n    // shm_open cleanup\n    fd = shm_unlink(STORAGE_ID);\n    if (fd == -1)\n    &#123;\n        perror(&quot;unlink&quot;);\n        return 100;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"题外话-Q-amp-A\"><a href=\"#题外话-Q-amp-A\" class=\"headerlink\" title=\"题外话 Q&amp;A:\"></a>题外话 Q&amp;A:</h2><h3 id=\"Q-mmap下的资源需要锁吗\"><a href=\"#Q-mmap下的资源需要锁吗\" class=\"headerlink\" title=\"Q:mmap下的资源需要锁吗?\"></a>Q:mmap下的资源需要锁吗?</h3><p>A:</p>\n<p>需要锁:</p>\n<p><strong>Semaphores</strong></p>\n<p><strong>共享内存的</strong>mutex</p>\n<p>​\tpthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致</p>\n<p>如何使用?</p>\n<p>通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息</p>\n<p><a href=\"https://blog.csdn.net/qq_35396127/article/details/78942245\">https://blog.csdn.net/qq_35396127/article/details/78942245</a></p>\n<p><strong>文件锁</strong></p>\n<p>在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust</p>\n<h3 id=\"Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink\"><a href=\"#Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink\" class=\"headerlink\" title=\"Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink\"></a>Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink</h3><p>A:</p>\n<p>The operation of <strong>shm_unlink</strong>() is analogous to <em><strong><a href=\"https://linux.die.net/man/2/unlink\">unlink</a></strong>(2)</em>: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful <strong>shm_unlink</strong>(), attempts to <strong>shm_open</strong>() an object with the same <em>name</em> will fail (unless <strong>O_CREAT</strong> was specified, in which case a new, distinct object is created).</p>\n<p>文件存在于&#x2F;dev&#x2F;shm下,如果不调用该函数,文件会一直存在</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clcg0w03y00077dt3fgyi6pb3","tag_id":"clcg0w03w00027dt30sgc12yz","_id":"clcg0w03z000a7dt31wuq6qi4"},{"post_id":"clcg0w03y00077dt3fgyi6pb3","tag_id":"clcg0w03y00067dt326uu74zf","_id":"clcg0w040000c7dt3hd5h24f6"},{"post_id":"clcg0w03s00007dt3apqp20n5","tag_id":"clcg0w03w00027dt30sgc12yz","_id":"clcg0w040000f7dt3531wgmbn"},{"post_id":"clcg0w03s00007dt3apqp20n5","tag_id":"clcg0w03y00067dt326uu74zf","_id":"clcg0w041000h7dt3g5oy0lb0"},{"post_id":"clcg0w03v00017dt37w1304ki","tag_id":"clcg0w03w00027dt30sgc12yz","_id":"clcg0w041000l7dt39rl0etie"},{"post_id":"clcg0w03v00017dt37w1304ki","tag_id":"clcg0w040000e7dt36c0tdsut","_id":"clcg0w042000n7dt3e61z3tao"},{"post_id":"clcg0w03w00037dt3burc1sb5","tag_id":"clcg0w03w00027dt30sgc12yz","_id":"clcg0w042000q7dt3gpot8ycg"},{"post_id":"clcg0w03x00047dt3d6jhdvey","tag_id":"clcg0w042000o7dt310ez8ith","_id":"clcg0w043000t7dt37g1091a7"},{"post_id":"clcg0w043000v7dt3ber8elqk","tag_id":"clcg0w03w00027dt30sgc12yz","_id":"clcg0w044000x7dt3f7tg8hxn"}],"Tag":[{"name":"tech","_id":"clcg0w03w00027dt30sgc12yz"},{"name":"mysql","_id":"clcg0w03y00067dt326uu74zf"},{"name":"Linux","_id":"clcg0w040000e7dt36c0tdsut"},{"name":"life","_id":"clcg0w042000o7dt310ez8ith"}]}}