<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>shm与mmap</title><meta name="description" content="A personal website for logging the techs and life"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="shmget 和 shm_open+mmap是两种不同的共享内存用法,
shmget是老式system V 模型,
shm_open 是POSIX下的产物.
mmap和System V共享内存的主要区别在于：

sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；
mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。

内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。

匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。
文件映射有MAP_PRIVATE和MAP_SHARED两种。前者使用COW.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">fakecore's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">shm与mmap</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#shmget"><span class="toc-text">shmget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shm-open-mmap"><span class="toc-text">shm_open+mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D-Q-amp-A"><span class="toc-text">题外话 Q&amp;A:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-mmap%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E9%9C%80%E8%A6%81%E9%94%81%E5%90%97"><span class="toc-text">Q:mmap下的资源需要锁吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-shm-open%E8%8E%B7%E5%8F%96%E7%9A%84%E8%B5%84%E6%BA%90%E8%83%BD%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81%E5%90%97-%E4%B8%8D%E8%B0%83%E7%94%A8shm-unlink"><span class="toc-text">Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/linux"><i class="tag post-item-tag">linux</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">shm与mmap</h1><time class="has-text-grey" datetime="2023-01-02T21:53:36.000Z">2023-01-03</time><article class="mt-2 post-content"><p>shmget 和 shm_open+mmap是两种不同的共享内存用法,</p>
<p>shmget是老式system V 模型,</p>
<p>shm_open 是POSIX下的产物.</p>
<p>mmap和System V共享内存的主要区别在于：</p>
<ul>
<li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li>
<li>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。</li>
</ul>
<p>内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种。</p>
<ul>
<li>匿名映射使用进程的虚拟内存空间，它和malloc(3)类似，实际上有些malloc实现会使用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。</li>
<li>文件映射有<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code>两种。前者使用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，然后由内核自动同步到映射文件上。</li>
</ul>
<p>shmget用法 shmget(IPC_PRIVATE,size,flag)</p>
<p>shm_open 创建一个共享内存(文件,&#x2F;dev&#x2F;shm下),返回一个fd.通过ftruncate指定文件大小</p>
<p>mmap通过fd attach上这个地址,进行操作</p>
<h2 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h2><p>compared to shm_open+mmap, shm_get used the old System V shared memory model.</p>
<pre><code class="c">#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
int shmget(key_t key, size_t size, int shmflg);
</code></pre>
<p>key: It may be used either to obtain the identifier of a previously created shared memory segment (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.</p>
<p>获取一个特定shm</p>
<p>size: A new shared memory segment, with size equal to the value of size rounded up to a  multi-<br>       ple  of  PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE,<br>       no shared memory segment corresponding to key exists, and IPC_CREAT is specified in  shm-<br>       flg.</p>
<p> If  shmflg  specifies both IPC_CREAT and IPC_EXCL and a shared memory segment already ex-<br>       ists for key, then shmget() fails with errno set to EEXIST.  (This is  analogous  to  the<br>       effect of the combination O_CREAT | O_EXCL for open(2).)</p>
<p>如果shmflag同时指定了<code>IPC_CREAT</code> 和<code>IPC_EXCL</code>,同时有一个已存在的KEY共享内存,shmget将会失败.</p>
<p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On error, -1 is returned,  and<br>       errno is set to indicate the error.</p>
<p>可以理解成返回一个fd,指向可用的shm segement</p>
<h2 id="shm-open-mmap"><a href="#shm-open-mmap" class="headerlink" title="shm_open+mmap"></a>shm_open+mmap</h2><pre><code class="c">#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;        /* For mode constants */
#include &lt;fcntl.h&gt;           /* For O_* constants */

int shm_open(const char *name, int oflag, mode_t mode);

int shm_unlink(const char *name);

Link with -lrt.
</code></pre>
<p>shm_open: 可以创建或者打开已存在的shm segement.</p>
<p><code>open</code> is the same as <code>shm_open</code>.</p>
<p>shm_unlink: 关闭shm segement</p>
<p> <strong>oflag</strong> is a bit mask created by ORing together exactly one of O_RDONLY or O_RDWR  and  any<br>       of the other flags listed here:</p>
<pre><code>   O_RDONLY
          Open the object for read access.  A shared memory object opened in this way can be
          mmap(2)ed only for read (PROT_READ) access.

   O_RDWR Open the object for read-write access.

   O_CREAT
          Create the shared memory object if it does not exist.  The user and  group  owner-
          ship  of  the object are taken from the corresponding effective IDs of the calling
          process, and the object&#39;s permission bits are set according  to  the  low-order  9
          bits  of  mode,  except that those bits set in the process file mode creation mask
          (see umask(2)) are cleared for the new object.  A set of macro constants which can
          be  used to define mode is listed in open(2).  (Symbolic definitions of these con-
          stants can be obtained by including &lt;sys/stat.h&gt;.)

          A new shared memory object initially has zero length--the size of the  object  can
          be  set  using  ftruncate(2).  The newly allocated bytes of a shared memory object
          are automatically initialized to 0.

   O_EXCL If O_CREAT was also specified, and a shared memory object with the given name  al-
          ready exists, return an error.  The check for the existence of the object, and its
          creation if it does not exist, are performed atomically.

   O_TRUNC
          If the shared memory object already exists, truncate it to zero bytes.
</code></pre>
<p><strong>mmap</strong></p>
<pre><code class="c"> #include &lt;sys/mman.h&gt;

void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);

//See NOTES for information on feature test macro requirements.
</code></pre>
<pre><code>mmap() creates a new mapping in the virtual address space of the
       calling process.  The starting address for the new mapping is
       specified in addr.  The length argument specifies the length of
       the mapping (which must be greater than 0).

RETURN VALUE
On success, mmap() returns a pointer to the mapped area.  On
       error, the value MAP_FAILED (that is, (void *) -1) is returned,
       and errno is set to indicate the error.

On success, munmap() returns 0.  On failure, it returns -1, and
errno is set to indicate the error (probably to EINVAL).
</code></pre>
<p><strong>ftruncate</strong></p>
<p>把文件size变到指定大小</p>
<pre><code class="c">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
</code></pre>
<pre><code>The truncate()  and ftruncate() functions cause the regular file named by path or refer-
       enced by fd to be truncated to a size of precisely length bytes.

If the file previously was larger than this size, the extra data is lost.   If  the  file
   previously was shorter, it is extended, and the extended part reads as null bytes (&#39;\0&#39;).

   The file offset is not changed.

   If  the  size  changed, then the st_ctime and st_mtime fields (respectively, time of last
   status change and time of last modification; see inode(7)) for the file are updated,  and
   the set-user-ID and set-group-ID mode bits may be cleared.

   With  ftruncate(),  the  file must be open for writing; with truncate(), the file must be
   writable.
</code></pre>
<p>simply code</p>
<pre><code class="c">//get.c
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define STORAGE_ID &quot;/SHM_TEST&quot;
#define STORAGE_SIZE 32

int main(int argc, char *argv[])
&#123;
    int res;
    int fd;
    char data[STORAGE_SIZE];
    pid_t pid;
    void *addr;

    pid = getpid();

    // get shared memory file descriptor (NOT a file,but act as a regular file)
    fd = shm_open(STORAGE_ID, O_RDONLY, S_IRUSR | S_IWUSR);
    if (fd == -1)
    &#123;
        perror(&quot;open&quot;);
        return 10;
    &#125;

    // map shared memory to process address space
    addr = mmap(NULL, STORAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED)
    &#123;
        perror(&quot;mmap&quot;);
        return 30;
    &#125;

    // place data into memory
    memcpy(data, addr, STORAGE_SIZE);

    printf(&quot;PID %d: Read from shared memory: \&quot;%s\&quot;\n&quot;, pid, data);

    return 0;
&#125;
</code></pre>
<pre><code class="c">//set.c
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define STORAGE_ID &quot;/SHM_TEST&quot;
#define STORAGE_SIZE 32
#define DATA &quot;Hello, World! From PID %d&quot;

int main(int argc, char *argv[])
&#123;
    int res;
    int fd;
    int len;
    pid_t pid;
    void *addr;
    char data[STORAGE_SIZE];

    pid = getpid();
    sprintf(data, DATA, pid);

    // get shared memory file descriptor (NOT a file)
    fd = shm_open(STORAGE_ID, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
    if (fd == -1)
    &#123;
        perror(&quot;open&quot;);
        return 10;
    &#125;

    // extend shared memory object as by default it&#39;s initialized with size 0
    res = ftruncate(fd, STORAGE_SIZE);
    if (res == -1)
    &#123;
        perror(&quot;ftruncate&quot;);
        return 20;
    &#125;

    // map shared memory to process address space
    addr = mmap(NULL, STORAGE_SIZE, PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED)
    &#123;
        perror(&quot;mmap&quot;);
        return 30;
    &#125;

    // place data into memory
    len = strlen(data) + 1;
    memcpy(addr, data, len);

    // wait for someone to read it
    sleep(2);

    // mmap cleanup
    res = munmap(addr, STORAGE_SIZE);
    if (res == -1)
    &#123;
        perror(&quot;munmap&quot;);
        return 40;
    &#125;

    // shm_open cleanup
    fd = shm_unlink(STORAGE_ID);
    if (fd == -1)
    &#123;
        perror(&quot;unlink&quot;);
        return 100;
    &#125;

    return 0;
&#125;
</code></pre>
<h2 id="题外话-Q-amp-A"><a href="#题外话-Q-amp-A" class="headerlink" title="题外话 Q&amp;A:"></a>题外话 Q&amp;A:</h2><h3 id="Q-mmap下的资源需要锁吗"><a href="#Q-mmap下的资源需要锁吗" class="headerlink" title="Q:mmap下的资源需要锁吗?"></a>Q:mmap下的资源需要锁吗?</h3><p>A:</p>
<p>需要锁:</p>
<p><strong>Semaphores</strong></p>
<p><strong>共享内存的</strong>mutex</p>
<p>​	pthread_mutexattr_setrobust() ，将 pthread 互斥锁初始化为“robust”，如果持有互斥锁的进程死了，下一个获取它的线程将收到 EOWNERDEAD（但仍然成功获取互斥锁），以便它知道执行任何清理。然后它需要使用 pthread_mutex_consistent() 通知获取的互斥锁再次一致</p>
<p>如何使用?</p>
<p>通过mmap获取一块共享内存,共享内存内存在pthread_mutex相关信息</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35396127/article/details/78942245">https://blog.csdn.net/qq_35396127/article/details/78942245</a></p>
<p><strong>文件锁</strong></p>
<p>在linux 系统中，flock函数是为解决多进程对同一文件的读写冲突的，而flock函数只能锁定整个文件，无法锁定文件的某一区域。且flock可以保证robust</p>
<h3 id="Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink"><a href="#Q-shm-open获取的资源能自动销毁吗-不调用shm-unlink" class="headerlink" title="Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink"></a>Q:shm_open获取的资源能自动销毁吗?不调用shm_unlink</h3><p>A:</p>
<p>The operation of <strong>shm_unlink</strong>() is analogous to <em><strong><a target="_blank" rel="noopener" href="https://linux.die.net/man/2/unlink">unlink</a></strong>(2)</em>: it removes a shared memory object name, and, once all processes have unmapped the object, de-allocates and destroys the contents of the associated memory region. After a successful <strong>shm_unlink</strong>(), attempts to <strong>shm_open</strong>() an object with the same <em>name</em> will fail (unless <strong>O_CREAT</strong> was specified, in which case a new, distinct object is created).</p>
<p>文件存在于&#x2F;dev&#x2F;shm下,如果不调用该函数,文件会一直存在</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/rc_and_refcell/" title="rust (Rc, RefCell) and( Arc, Mutex)"><span class="has-text-weight-semibold">Next: rust (Rc, RefCell) and( Arc, Mutex)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fakecore/fakecore.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fakecore"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> fakecore 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>