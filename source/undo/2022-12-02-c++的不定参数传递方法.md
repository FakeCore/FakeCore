---
layout: post
title: c++的不定参数传递方法
date: 2022-12-02 17:20:00 +0800
last_modified_at: 2022-12-16 17:21:05 +0800
tags: [c++]
author: fakecore
author_url:
---

## 不定参数

关于不定参数,让我们来看看这个.

```c++
int printf(const char* format...);
```

是不是很熟悉,常见的printf函数的参数就是不定参数.



让我们再来看看一段代码,如何自己写不定参数.

```c++
#include <iostream>
#include <cstdarg>
 
void simple_printf(const char* fmt...) // C-style "const char* fmt, ..." is also valid
{
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        } else if (*fmt == 'c') {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        } else if (*fmt == 'f') {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
 
    va_end(args);
}
 
int main()
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5); 
}
```



| [va_start](https://en.cppreference.com/w/cpp/utility/variadic/va_start) | enables access to variadic function arguments (function macro) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [va_arg](https://en.cppreference.com/w/cpp/utility/variadic/va_arg) | accesses the next variadic function argument (function macro) |
| [va_copy](https://en.cppreference.com/w/cpp/utility/variadic/va_copy)(C++11) | makes a copy of the variadic function arguments (function macro) |
| [va_end](https://en.cppreference.com/w/cpp/utility/variadic/va_end) | ends traversal of the variadic function arguments (function macro) |
| [va_list](https://en.cppreference.com/w/cpp/utility/variadic/va_list) | holds the information needed by [va_start](https://en.cppreference.com/w/cpp/utility/variadic/va_start), [va_arg](https://en.cppreference.com/w/cpp/utility/variadic/va_arg), [va_end](https://en.cppreference.com/w/cpp/utility/variadic/va_end), and [va_copy](https://en.cppreference.com/w/cpp/utility/variadic/va_copy) (typedef) |
|                                                              |                                                              |

```c++
typedef  char *  va_list;
/*
   Storage alignment properties -- 堆栈按X对齐
*/
#define  _AUPBND        (sizeof (X) - 1) 
#define  _ADNBND        (sizeof (X) - 1)
 
/* Variable argument list macro definitions -- 变参函数内部实现需要用到的宏 */                  
#define _bnd(X, bnd)    (((sizeof (X)) + (bnd)) & (~(bnd)))
#define va_start(ap, A)  (void) ((ap) = (((char *) &(A)) + (_bnd (A,_AUPBND))))
#define va_arg(ap, T)   (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
#define va_end(ap)     (void) 0

```

c语言传递参数时,使用push指令从右到左将参数逐个压栈.

_bnd 计算类型为X的参数在栈中占据的字节数，是数据(类型由bnd决定)对齐后的字节数。

va_start(ap,A) ，初始化参数指针ap，将函数参数A右边第一个参数的地址赋给ap。 A必须是一个参数的指针，所以此种类型函数至少要有一个普通的参数。

va_arg 获得ap指向参数的值，并使ap指向下一个参数，T用来指明当前参数类型。

va_end 删除ap指针



## 不定参数模版

https://www.cnblogs.com/qicosmos/p/4325949.html

声明

```c++
template <class... T>
void f(T... args);
```

模版展开

```
template<class F, class... Args>void expand(const F& f, Args&&...args) 
{
  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》
  initializer_list<int>{(f(std::forward< Args>(args)),0)...};
}
expand([](int i){cout<<i<<endl;}, 1,2,3);
```

有兴趣可以去查看std::tuple的数据结构
